{"entries":[{"timestamp":1753556188219,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":75,"length1":134,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":182,"length1":40,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":211,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"dns.ts","value":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetSim {\n    let myIP = \"10.0.100\" // Set each device's unique IP\n    let mySerial = control.deviceSerialNumber()\n\n    radio.setGroup(1) // Ensure all devices are on the same channel\n\n    radio.onReceivedString(function (msg: string) {\n        let parts = msg.split(\"|\")\n        let cmdAndIp = parts[0].split(\":\")\n        let cmd = cmdAndIp[0]\n        let ip = cmdAndIp[1]\n        let replyTo = parts[1]\n\n        if (cmd == \"whois\" && ip == myIP) {\n            // Simulate a response targeted to a specific serial\n            // MakeCode radio is broadcast-only, so we simulate direct replies\n            radio.sendString(\"answer:\" + myIP + \"|\" + mySerial)\n        }\n    })\n\n    // Utility to send a whois query\n    export function sendWhoIs(ipTarget: string) {\n        radio.sendString(\"whois:\" + ipTarget + \"|\" + mySerial)\n    }\n}"}]},{"timestamp":1753556818619,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":82,"length1":64,"diffs":[[1,"    let myIP = \"10.0.100\" // Set each device's unique IP\n"]]}]}]},{"timestamp":1753556831133,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":366,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":1,"length1":80,"diffs":[[1,""]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":63,"length1":242,"diffs":[[1,"namespace NetSim {\n    export let myIP = \"10.0.100\" // Set each device's unique IP\n    let mySerial = control.deviceSerialNumber()\n"]]},{"start1":195,"length1":23,"diffs":[[1,"    radio.setGroup(1) // Ensure all devices are on the same channel\n"]]},{"start1":316,"length1":173,"diffs":[[1,"        let parts = msg.split(\"|\")\n        let cmdAndIp = parts[0].split(\":\")\n        let cmd = cmdAndIp[0]\n        let ip = cmdAndIp[1]\n        let replyTo = parts[1]\n"]]},{"start1":529,"length1":117,"diffs":[[1,"            // Simulate a response targeted to a specific serial\n            // MakeCode radio is broadcast-only, so we simulate direct replies\n            radio.sendString(\"answer:\" + myIP + \"|\" + mySerial)\n"]]},{"start1":747,"length1":0,"diffs":[[1,"    })\n"]]},{"start1":755,"length1":312,"diffs":[[1,""]]},{"start1":792,"length1":697,"diffs":[[1,"    export function sendWhoIs(ipTarget: string) {\n        radio.sendString(\"whois:\" + ipTarget + \"|\" + mySerial)\n"]]}]}]},{"timestamp":1753557520732,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\nNetWorking.sendWhoIs(\"10.0.100\").then(function(a:number) {\n    console.log(a)\n})"]]}]}]},{"timestamp":1753557532449,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":19,"diffs":[[1,""]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":305,"length1":49,"diffs":[[1,""]]},{"start1":1031,"length1":192,"diffs":[[1,""]]},{"start1":1780,"length1":414,"diffs":[[1,""]]}]}]},{"timestamp":1753558124517,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":295,"diffs":[[1,"pause(randint(100))"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":317,"length1":60,"diffs":[[1,"        \"dns.ts\"\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":379,"length1":53,"diffs":[[1,"    radio.onReceivedString(function (msg: string) {\n"]]},{"start1":1540,"length1":69,"diffs":[[1,"            radio.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n"]]},{"start1":2123,"length1":80,"diffs":[[1,"            radio.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n"]]}]},{"type":"added","filename":"radio2.ts","value":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 128;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 100;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 28\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    let transmittingSerial: boolean;\n    let initialized = false;\n\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    //% blockId=radio_on_number_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=20\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    //% blockId=radio_on_value_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=19\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    //% blockId=radio_on_string_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=18\n    export function onReceivedString(cb: (receivedString: string) => void) {\n        init();\n        onReceivedStringHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    //% blockId=radio_on_buffer_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    //% blockGap=8\n    //% blockId=radio_received_packet block=\"received packet %type=radio_packet_property\" blockGap=16\n    //% group=\"Receive\"\n    //% weight=16\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    //% weight=60\n    //% blockId=radio_datagram_send block=\"radio send number %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    //% weight=59\n    //% blockId=radio_datagram_send_value block=\"radio send|value %name|= %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    //% weight=58\n    //% blockId=radio_datagram_send_string block=\"radio send string %msg\"\n    //% msg.shadowOptions.toString=true\n    //% group=\"Send\"\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    //% weight=57\n    //% advanced=true\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    /**\n    * Set the radio to transmit the serial number in each message.\n    * @param transmit value indicating if the serial number is transmitted, eg: true\n    */\n    //% help=radio/set-transmit-serial-number\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_transmit_serial_number block=\"radio set transmit serial number %transmit\"\n    //% advanced=true\n    export function setTransmitSerialNumber(transmit: boolean) {\n        transmittingSerial = transmit;\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}"},{"type":"added","filename":"shims.d.ts","value":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"}]},{"timestamp":1753558671353,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":211,"length1":52,"diffs":[[1,"NetWorking.SendDataTo(\"10.0.100\", { msg: \"88888888888888888888888888888888888888\" })"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":2026,"length1":781,"diffs":[[1,""]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":435,"length1":72,"diffs":[[1,"    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 28\n"]]}]}]},{"timestamp":1753559310019,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":211,"length1":42,"diffs":[[1,"NetWorking.SendDataTo(\"10.0.100\", { msg: {msg:100}})"]]}]}]},{"timestamp":1753559310750,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":211,"length1":245,"diffs":[[1,"NetWorking.SendDataTo(\"10.0.100\", { msg:})"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":356,"length1":39,"diffs":[[1,"        \"shims.d.ts\"\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":3219,"length1":146,"diffs":[[1,""]]}]},{"type":"added","filename":"ntp.ts","value":"namespace NetWorking {\n    const NTP_REQUEST = \"ntp-req\";\n    const NTP_RESPONSE = \"ntp-resp\";\n    const SYNC_ATTEMPTS = 3;\n    const SYNC_DELAY_MS = 100;\n\n    export function requestTime(serverIp: string): Promise<number> {\n        let offsets: number[] = [];\n        let attempt = 0;\n\n        function syncOnce(): Promise<void> {\n            return new Promise<void>((resolve) => {\n                let startMicros = control.micros();\n                NetWorking.SendDataTo(serverIp, {\n                    type: NTP_REQUEST,\n                    origin: NetWorking.getMyIP(),\n                    timestamp: startMicros\n                });\n\n                NetWorking.WaitForData(serverIp).then(raw => {\n                    let packet = JSON.parse(raw);\n                    let nowMicros = control.micros();\n                    if (packet && packet.type === NTP_RESPONSE && typeof packet.timestamp === \"number\") {\n                        let roundTrip = nowMicros - startMicros;\n                        let offset = packet.timestamp - startMicros - roundTrip / 2;\n                        offsets.push(offset);\n                    }\n                    resolve(null);\n                }).catch(() => resolve(null));\n            });\n        }\n\n        return new Promise<number>((resolve, reject) => {\n            function runSyncCycle(): void {\n                if (attempt < SYNC_ATTEMPTS) {\n                    syncOnce().then(() => {\n                        pause(SYNC_DELAY_MS);\n                        attempt++;\n                        runSyncCycle();\n                    });\n                } else {\n                    if (offsets.length === 0) {\n                        reject(\"No responses received.\");\n                    } else {\n                        let avgOffset = offsets.reduce((a, b) => a + b, 0) / offsets.length;\n                        resolve(avgOffset);\n                    }\n                }\n            }\n\n            runSyncCycle();\n        });\n    }\n\n    export function safeParse(str: string, maxDepth: number = 5): any {\n        try {\n            let obj = JSON.parse(str);\n            return sanitize(obj, 0, maxDepth);\n        } catch (e) {\n            console.log(\"JSON parse failed:\" + e);\n            return null;\n        }\n    }\n\n    function sanitize(node: any, depth: number, maxDepth: number): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        if (node === null || typeof node !== \"object\") return node;\n\n        if (Array.isArray(node)) {\n            return node.map((item:any) => sanitize(item, depth + 1, maxDepth));\n        }\n\n        let safeObj: any = {};\n        for (let key of node) {\n            try {\n                safeObj[key] = sanitize(node[key], depth + 1, maxDepth);\n            } catch (e) {\n                safeObj[key] = \"[Parse error]\";\n            }\n        }\n        return safeObj;\n    }\n\n    export function handleRequests(): void {\n        NetWorking.onPacketReceived((fromIp: string, data: string) => {\n            let packet = JSON.parse(data);\n            if (packet && packet.type === NTP_REQUEST) {\n                NetWorking.SendDataTo(fromIp, {\n                    type: NTP_RESPONSE,\n                    origin: NetWorking.getMyIP(),\n                    timestamp: control.micros()\n                });\n            }\n        });\n    }\n}"}]},{"timestamp":1753559900990,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"NetWorking.WaitForData(\"10.0.100\").then(function (dat) {\r\n    console.log(\"Got data:\" + dat)\r\n}).catch(function (err) {\r\n    console.log(\"Error:\" + err)\r\n})\r\n\r\npause(100) // Give some time for listener to hook\r\nNetWorking.SendDataTo(\"10.0.100\", { msg: control.micros()})\r\nNetWorking.SendDataTo(\"10.0.100\", { msg: control.micros() })\r\nNetWorking.SendDataTo(\"10.0.100\", { msg: control.micros() })\r\nNetWorking.SendDataTo(\"10.0.100\", { msg: control.micros() })"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":356,"length1":21,"diffs":[[1,"        \"shims.d.ts\",\n        \"ntp.ts\"\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":354,"length1":5,"diffs":[[1,"\n"]]},{"start1":1213,"length1":0,"diffs":[[1,"                waitForData = null;\n"]]},{"start1":1319,"length1":24,"diffs":[[1,""]]},{"start1":3272,"length1":1524,"diffs":[[1,"    export function onPacketReceived(a:(fromIp:string,data:string) => void) {\n        \n"]]}]},{"type":"removed","filename":"ntp.ts","value":"namespace NetWorking {\n    const NTP_REQUEST = \"ntp-req\";\n    const NTP_RESPONSE = \"ntp-resp\";\n    const SYNC_ATTEMPTS = 3;\n    const SYNC_DELAY_MS = 100;\n\n    export function requestTime(serverIp: string): Promise<number> {\n        let offsets: number[] = [];\n        let attempt = 0;\n\n        function syncOnce(): Promise<void> {\n            return new Promise<void>((resolve) => {\n                let startMicros = control.micros();\n                NetWorking.SendDataTo(serverIp, {\n                    type: NTP_REQUEST,\n                    origin: NetWorking.getMyIP(),\n                    timestamp: startMicros\n                });\n\n                NetWorking.WaitForData(serverIp).then(raw => {\n                    let packet = JSON.parse(raw);\n                    let nowMicros = control.micros();\n                    if (packet && packet.type === NTP_RESPONSE && typeof packet.timestamp === \"number\") {\n                        let roundTrip = nowMicros - startMicros;\n                        let offset = packet.timestamp - startMicros - roundTrip / 2;\n                        offsets.push(offset);\n                    }\n                    resolve(null);\n                }).catch(() => resolve(null));\n            });\n        }\n\n        return new Promise<number>((resolve, reject) => {\n            function runSyncCycle(): void {\n                if (attempt < SYNC_ATTEMPTS) {\n                    syncOnce().then(() => {\n                        pause(SYNC_DELAY_MS);\n                        attempt++;\n                        runSyncCycle();\n                    });\n                } else {\n                    if (offsets.length === 0) {\n                        reject(\"No responses received.\");\n                    } else {\n                        let avgOffset = offsets.reduce((a, b) => a + b, 0) / offsets.length;\n                        resolve(avgOffset);\n                    }\n                }\n            }\n\n            runSyncCycle();\n        });\n    }\n\n    export function safeParse(str: string, maxDepth: number = 5): any {\n        try {\n            let obj = JSON.parse(str);\n            return sanitize(obj, 0, maxDepth);\n        } catch (e) {\n            console.log(\"JSON parse failed:\" + e);\n            return null;\n        }\n    }\n\n    function sanitize(node: any, depth: number, maxDepth: number): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        if (node === null || typeof node !== \"object\") return node;\n\n        if (Array.isArray(node)) {\n            return node.map((item:any) => sanitize(item, depth + 1, maxDepth));\n        }\n\n        let safeObj: any = {};\n        for (let key of node) {\n            try {\n                safeObj[key] = sanitize(node[key], depth + 1, maxDepth);\n            } catch (e) {\n                safeObj[key] = \"[Parse error]\";\n            }\n        }\n        return safeObj;\n    }\n\n    export function handleRequests(): void {\n        NetWorking.onPacketReceived((fromIp: string, data: string) => {\n            let packet = JSON.parse(data);\n            if (packet && packet.type === NTP_REQUEST) {\n                NetWorking.SendDataTo(fromIp, {\n                    type: NTP_RESPONSE,\n                    origin: NetWorking.getMyIP(),\n                    timestamp: control.micros()\n                });\n            }\n        });\n    }\n}"}]},{"timestamp":1753560499056,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":220,"diffs":[[1,""]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":86,"length1":57,"diffs":[[1,""]]},{"start1":305,"length1":78,"diffs":[[1,"    let waitForData:(dat:string) => void = null;\n    \n"]]},{"start1":1182,"length1":82,"diffs":[[1,"                waitForData(data);\n"]]},{"start1":1296,"length1":156,"diffs":[[1,"     * \n"]]},{"start1":2015,"length1":226,"diffs":[[1,"  \n    function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n"]]},{"start1":2374,"length1":107,"diffs":[[1,"            return '[' + obj.map((item:any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n"]]},{"start1":2798,"length1":202,"diffs":[[1,"\n    export function SendDataTo(ip:string,data:any) {\n        sendWhoIs(ip).then(function(serial) {\n"]]},{"start1":2995,"length1":567,"diffs":[[1,"    export function WaitForData(fromIp:string) {\n        return new Promise<string>(function(resolve,reject){\n             waitForData = function(dat) {\n                 resolve(dat);\n             }\n"]]},{"start1":3212,"length1":55,"diffs":[[1,"    export function getMyIP():string {return myIP};\n"]]}]}]},{"timestamp":1753561098360,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":116,"length1":745,"diffs":[[1,"       constructor()\n"]]},{"start1":3524,"length1":419,"diffs":[[1,"    /**  \n     * Add a Handler to be ran when a data packet is recived from the ip specifed by the fromIp param.\n     * Many Handlers can be added , including of the same IP\n     * put your handler on the .then() part of the Promise<string> returned.\n     * @param fromIp the IP to lisen for.\n    */\n"]]},{"start1":3874,"length1":56,"diffs":[[1,"        return new Promise<string>(function (resolve, reject) {\n"]]}]}]},{"timestamp":1753563756800,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1187,"length1":14,"diffs":[[1,"\n"]]}]}]},{"timestamp":1753563758598,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1187,"length1":36,"diffs":[[1,"    radio.set\n"]]}]}]},{"timestamp":1753563762677,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1218,"length1":12,"diffs":[[1,"    \n"]]}]}]},{"timestamp":1753565104804,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1218,"length1":21,"diffs":[[1,"    radio.\n"]]}]}]},{"timestamp":1753565107496,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1218,"length1":0,"diffs":[[1,"    radio.raiseEvent\n"]]}]}]},{"timestamp":1753570531396,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":6560,"length1":21,"diffs":[[1,""]]}]}]},{"timestamp":1753570544145,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":2133,"length1":298,"diffs":[[1,""]]},{"start1":2485,"length1":84,"diffs":[[1,""]]},{"start1":2524,"length1":162,"diffs":[[1,"            responseHandler = resolve;\n"]]},{"start1":6561,"length1":276,"diffs":[[1,"    export function\n"]]}]}]},{"timestamp":1753571143063,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":55,"diffs":[[1,""]]},{"start1":134,"length1":0,"diffs":[[1,"NetWorking.SendDataTo(\"10.0.100\", \"World\")\r\nNetWorking.SendDataTo(\"10.0.100\", \"-----\")"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":2221,"length1":198,"diffs":[[1,"        for (let i of cache.entries()) {\n            let ip = i[0]\n            let entry = i[1]\n"]]},{"start1":2783,"length1":310,"diffs":[[1,"            if (UseDNSCache) cleanCache(); cache.has(ipTarget) ? resolve(cache.get)\n"]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":5966,"length1":23,"diffs":[[1,""]]}]}]},{"timestamp":1753571727784,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":849,"diffs":[[1,"NetWorking.UseDNSCache = true; // needed to use cache\r\nNetWorking.WaitForData(\"10.0.100\").then(function(d) {\r\n    console.log(d)\r\n"]]},{"start1":134,"length1":47,"diffs":[[1,"pause(100)\r\nNetWorking.SendDataTo(\"10.0.100\",\"Hello\")\r\n"]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":5966,"length1":0,"diffs":[[1,"            pause(100)\n"]]}]}]},{"timestamp":1753572411244,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,"NetWorking.UseDNSCache = false // enable caching\r\n\r\nlet t1 = control.micros()\r\nconsole.log(\"Started WaitForData at micros: \" + t1)\r\nlet a = 0\r\nNetWorking.WaitForData(\"10.0.100\").then(function (d) {\r\n    if (a > 20) return;\r\n    let t2 = control.micros()\r\n    console.log(\"Received data at micros: \" + t2)\r\n    console.log(\"WaitForData duration: \" + (t2 - t1) + \" µs\")\r\n    console.log(\"Received: \" + d)\r\n\r\n    pause(100) // simulate delay before sending\r\n\r\n    let t3 = control.micros()\r\n    console.log(\"Started SendDataTo at micros: \" + t3)\r\n\r\n    NetWorking.SendDataTo(\"10.0.100\", \"Hello\")\r\n\r\n    let t4 = control.micros()\r\n    console.log(\"SendDataTo completed at micros: \" + t4)\r\n    console.log(\"SendDataTo duration: \" + (t4 - t3) + \" µs\")\r\n    console.log(\"Total time from WaitForData start to Send complete: \" + (t4 - t1) + \" µs\")\r\n    a++\r\n})\r\n\r\nNetWorking.SendDataTo(\"10.0.100\",\"--start--\")"]]}]}]},{"timestamp":1753572501485,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":206,"diffs":[[1,"N"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1219,"length1":100,"diffs":[[1,"    radio2.onReceivedString(function (msg: string) {\n"]]},{"start1":1446,"length1":193,"diffs":[[1,""]]},{"start1":5807,"length1":433,"diffs":[[1,""]]}]}]},{"timestamp":1753573096822,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":89,"diffs":[[1,"NetWorking.UseDNSCache;\r\nNetWorking.sendWhoIs;\r\nNetWorking.safeStringify;\r\nNetWorking.SendDataTo;\r\nNetWorking.WaitForData;\r\nNetWorking.getMyIP;\r\nNetWorking.safeParse;\r\nNetWorking.myIP\r\nNetWorking.mySerial\r\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":899,"length1":68,"diffs":[[1,"    export let myIP = \"10.0.100\";\n"]]},{"start1":1493,"length1":191,"diffs":[[1,""]]},{"start1":1619,"length1":57,"diffs":[[1,"            radio.sendString(`ap:${myIP}|${mySerial}`);\n"]]},{"start1":1782,"length1":66,"diffs":[[1,"            radio.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n"]]},{"start1":2373,"length1":259,"diffs":[[1,""]]},{"start1":6285,"length1":306,"diffs":[[1,"            findingDevices = false;\n            radio.sendString(`PEER:*|${mySerial}|FIND`)\n"]]}]}]},{"timestamp":1753573689809,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":42,"diffs":[[1,""]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":899,"length1":102,"diffs":[[1,"    export let myIP = \"10.0.\" + control.deviceSerialNumber() % 100;\n"]]}]}]},{"timestamp":1753573953744,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1001,"length1":39,"diffs":[[1,"    export let mySerial = control.deviceSerialNumber();\n"]]}]}]},{"timestamp":1753638084666,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1001,"length1":63,"diffs":[[1,"    export let mySerial = control.dve;\n"]]}]}]},{"timestamp":1753638087549,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":55,"length1":51,"diffs":[[1,"NetWorking.GetPeers().then(function(a) {\r\n"]]},{"start1":129,"length1":75,"diffs":[[1,"})"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1001,"length1":82,"diffs":[[1,"    export let mySerial = control.deviceLongSerialNumber().to;\n"]]}]}]},{"timestamp":1753638986028,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"radio2.ts","patch":[{"start1":12254,"length1":35,"diffs":[[1,"        transmittingSerial = transmit;\n"]]}]}]},{"timestamp":1753638998204,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"radio2.ts","patch":[{"start1":245,"length1":36,"diffs":[[1,"    const MAX_PAYLOAD_LENGTH = 100;\n"]]},{"start1":1283,"length1":44,"diffs":[[1,"    let transmittingSerial: boolean;\n"]]}]}]},{"timestamp":1753639581020,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":42,"length1":29,"diffs":[[1,""]]},{"start1":138,"length1":143,"diffs":[[1,"NetWorking.sendWhoIs(a[0]).then(function(a) {\r\n    console.log(a)\r\n"]]},{"start1":209,"length1":0,"diffs":[[1,"})\r\n"]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":162,"length1":39,"diffs":[[1,"    const RADIO_MAX_PACKET_SIZE = 128;\n"]]},{"start1":245,"length1":36,"diffs":[[1,"    const MAX_PAYLOAD_LENGTH = 118;\n"]]}]}]},{"timestamp":1753640161735,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":42,"length1":89,"diffs":[[1,"NetWorking.WaitForData(\"*\")\r\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1057,"length1":0,"diffs":[[1,"    console.log(mySerial)\n"]]},{"start1":2545,"length1":169,"diffs":[[1,"                waitForData.forEach((a) => a.fromIp == ip ? a.func(data) : false)\n"]]},{"start1":5906,"length1":461,"diffs":[[1," * Registers a data handler for incoming packets from a specific IP.\n * Multiple handlers can be added for the same IP; each will receive its own callback.\n * Use `.then()` on the returned Handler object to define what happens when data is received.\n"]]},{"start1":6159,"length1":97,"diffs":[[1," * @param fromIp - The IP address to listen for incoming data packets.\n"]]},{"start1":6493,"length1":45,"diffs":[[1,"                    resolve(dat);\n"]]}]}]},{"timestamp":1753640696784,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":6791,"length1":34,"diffs":[[1,"                    resolve(safeParse(dat));\n"]]},{"start1":7605,"length1":136,"diffs":[[1,""]]},{"start1":7606,"length1":312,"diffs":[[1,"    export function safeParse(input: string, maxDepth: number = 5): any {\n        function tryParse(node: any, depth: number): any {\n            if (depth > maxDepth) return \"[Max depth exceeded]\";\n"]]},{"start1":7805,"length1":266,"diffs":[[1,"            if (typeof node === \"string\") {\n                if (node.indexOf(\"{\") >= 0 || node.indexOf(\"[\") >= 0) {\n                    try {\n                        let parsed = JSON.parse(node);\n                        return tryParse(parsed, depth + 1); // recurse deeper\n                    } catch {\n                        return node; // not actual JSON, just a string\n                    }\n"]]},{"start1":8221,"length1":0,"diffs":[[1,"                return node;\n"]]},{"start1":8264,"length1":35,"diffs":[[1,""]]},{"start1":8265,"length1":113,"diffs":[[1,"            if (Array.isArray(node)) {\n                let result = [];\n                for (let i = 0; i < node.length; i++) {\n                    result.push(tryParse(node[i], depth + 1));\n                }\n                return result;\n            }\n"]]},{"start1":8520,"length1":309,"diffs":[[1,"            if (typeof node === \"object\" && node !== null) {\n                let keys = Object.keys(node);\n                let result: any = {};\n                for (let i = 0; i < keys.length; i++) {\n                    let key = keys[i];\n                    result[key] = tryParse(node[key], depth + 1);\n                }\n                return result;\n"]]},{"start1":8889,"length1":27,"diffs":[[1,"\n            return node;\n"]]},{"start1":8926,"length1":162,"diffs":[[1,""]]},{"start1":8940,"length1":205,"diffs":[[1,"            let initial = JSON.parse(input);\n            return tryParse(initial, 0);\n"]]}]}]},{"timestamp":1753641289494,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":6325,"length1":8,"diffs":[[1,""]]}]}]},{"timestamp":1753641954562,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":6329,"length1":32,"diffs":[[1,""]]}]}]},{"timestamp":1753641960622,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1232,"length1":64,"diffs":[[1,"    radio.setGroup(1);\n"]]},{"start1":2519,"length1":171,"diffs":[[1,"                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\",\"\"))? a.func(data) : false)\n"]]},{"start1":2712,"length1":13,"diffs":[[1,"    });\n"]]},{"start1":2721,"length1":46,"diffs":[[1,"    \n    game.onUpdateInterval(100, function() {\n"]]},{"start1":3793,"length1":1,"diffs":[[1,"                \n"]]},{"start1":4081,"length1":180,"diffs":[[1,"            responseHandler = \n            function(n:number) {\n                if (UseDNSCache) addMapping(ipTarget,n)\n                resolve(n);\n            }\n"]]},{"start1":5959,"length1":162,"diffs":[[1,""]]},{"start1":6329,"length1":226,"diffs":[[1," * Note: JSON data will Not be \n * \n"]]},{"start1":6705,"length1":65,"diffs":[[1,"        return new Handler<string>(function (resolve) {\n"]]},{"start1":6831,"length1":239,"diffs":[[1,""]]},{"start1":6963,"length1":83,"diffs":[[1,"    let foundDevices:(dev:string[]) => void = null;\n    let found:string[] = []\n"]]},{"start1":7122,"length1":48,"diffs":[[1,"        return new Promise(function(resolve) {\n"]]},{"start1":7204,"length1":48,"diffs":[[1,"            control.runInParallel(function() {\n"]]},{"start1":7475,"length1":44,"diffs":[[1,"            foundDevices = function(dev) {\n"]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":1356,"length1":35,"diffs":[[1,"\n"]]},{"start1":4223,"length1":136,"diffs":[[1,"    export function onReceivedString(cb: (receivedString: string) => void) {\n"]]},{"start1":4354,"length1":58,"diffs":[[1,""]]}]}]},{"timestamp":1753642559882,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1232,"length1":192,"diffs":[[1,"    radio.setGroup(1); // this is passed to the low-level stuff\n    radio.setTransmitPower(7);\n"]]}]}]},{"timestamp":1753643492750,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":374,"length1":5,"diffs":[[1,""]]}]}]},{"timestamp":1753643495127,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":374,"length1":41,"diffs":[[1,"conso"]]}]}]},{"timestamp":1753903929878,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":127,"length1":10,"diffs":[[1,""]]}]}]},{"timestamp":1753903934424,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":42,"length1":57,"diffs":[[1,"NetWorking.WaitForData(\"*\").then(function(str) {\r\n"]]},{"start1":127,"length1":78,"diffs":[[1,"    str.\r\n"]]},{"start1":384,"length1":0,"diffs":[[1,"console.log(control.deviceSerialNumber())"]]}]}]},{"timestamp":1753904685558,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":3,"diffs":[[1,"NetWorking.SendDataTo(\"10.0.100\",\"----\")\r\nNetWorking.WaitForData(\"*\").then(function(str:string) {\r\n    console.log(`Recived:${str}`)\r\n    let id = str.slice(str.indexOf('\"id\":'),20)\r\n    console.log(`id:${id}`)\r\n})\r\npause(3000)\r\nNetWorking.GetPeers().then(function(a:string[]) {\r\nconsole.log(JSON.stringify(a))\r\n    NetWorking.SendDataTo(a[0], {\r\n        \"id\": \"device-42\",\r\n        \"temp\": 22.5,\r\n        \"humidity\": 58,\r\n        \"battery\": 3.7\r\n    })\r\n})\r\n"]]}]}]},{"timestamp":1753904687231,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":122,"diffs":[[1,"net"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1425,"length1":107,"diffs":[[1,"    radio2.onReceivedString(function (msg: string) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n"]]},{"start1":2180,"length1":69,"diffs":[[1,"            radio2.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n"]]},{"start1":2405,"length1":159,"diffs":[[1,""]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":1283,"length1":46,"diffs":[[1,"    let transmittingSerial: boolean = true;\n"]]},{"start1":1569,"length1":86,"diffs":[[1,"    let onReceivedStringHandler: (receivedString: string) => void;\n"]]},{"start1":2835,"length1":86,"diffs":[[1,"                        onReceivedStringHandler(lastPacket.stringPayload);\n"]]},{"start1":4257,"length1":116,"diffs":[[1,"    export function onReceivedString(cb: (receivedString: string) => void,nooverride?:boolean) {\n"]]},{"start1":11984,"length1":0,"diffs":[[1,"    /**\n    * Set the radio to transmit the serial number in each message.\n    * @param transmit value indicating if the serial number is transmitted, eg: true\n    */\n    //% help=radio/set-transmit-serial-number\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_transmit_serial_number block=\"radio set transmit serial number %transmit\"\n    //% advanced=true\n    export function setTransmitSerialNumber(transmit: boolean) {\n        transmittingSerial = true;\n    }\n\n"]]}]}]},{"timestamp":1753905286979,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":704,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"NetWorking_sendWhoIs\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"267\" y=\"151\"><value name=\"ipTarget\"><shadow type=\"text\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"TEXT\"></field></shadow></value></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":115,"diffs":[[1,"\r\n\r\nNetWorking.myIP = \"10.0.0\"\r\nNetWorking.mySerial = 0;\r\nNetWorking.GetPeers().then(function(a) {\r\n    console.log(a)\r\n})"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":2187,"length1":66,"diffs":[[1,"            radio2.sendString(\"answer:\" + (myIP ) + \"|\" + mySerial);\n"]]},{"start1":2415,"length1":167,"diffs":[[1,"                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`);}\n"]]},{"start1":7844,"length1":47,"diffs":[[1,""]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":3200,"length1":0,"diffs":[[1,"    //% blockId=radio_on_number_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=20\n"]]},{"start1":3652,"length1":0,"diffs":[[1,"    //% blockId=radio_on_value_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=19\n"]]},{"start1":4099,"length1":0,"diffs":[[1,"    //% blockId=radio_on_string_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=18\n"]]},{"start1":4694,"length1":0,"diffs":[[1,"    //% blockId=radio_on_buffer_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n"]]},{"start1":5165,"length1":0,"diffs":[[1,"    //% blockGap=8\n    //% blockId=radio_received_packet block=\"received packet %type=radio_packet_property\" blockGap=16\n    //% group=\"Receive\"\n    //% weight=16\n"]]},{"start1":9751,"length1":0,"diffs":[[1,"    //% weight=60\n    //% blockId=radio_datagram_send block=\"radio send number %value\" blockGap=8\n    //% group=\"Send\"\n"]]},{"start1":10561,"length1":0,"diffs":[[1,"    //% weight=59\n    //% blockId=radio_datagram_send_value block=\"radio send|value %name|= %value\" blockGap=8\n    //% group=\"Send\"\n"]]},{"start1":11277,"length1":0,"diffs":[[1,"    //% weight=58\n    //% blockId=radio_datagram_send_string block=\"radio send string %msg\"\n    //% msg.shadowOptions.toString=true\n    //% group=\"Send\"\n"]]},{"start1":11813,"length1":0,"diffs":[[1,"    //% weight=57\n    //% advanced=true\n"]]}]}]},{"timestamp":1753905885330,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":7849,"length1":0,"diffs":[[1,"\n    export function JsonLikeify(str:string):J\n"]]}]}]},{"timestamp":1753906130226,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":356,"length1":52,"diffs":[[1,"        \"shims.d.ts\"\n"]]}]},{"type":"added","filename":"multidevsettings.ts","value":""}]},{"timestamp":1753992771719,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"multidevsettings.ts","patch":[{"start1":0,"length1":22,"diffs":[[1,""]]}]}]},{"timestamp":1753992771742,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":86,"length1":21,"diffs":[[1,""]]},{"start1":671,"length1":62,"diffs":[[1,"        then(fn: (value: T) => void): void {\n"]]},{"start1":805,"length1":39,"diffs":[[1,"                fn(this.value);\n"]]},{"start1":1154,"length1":87,"diffs":[[1,"    let waitForData: { func: (dat: string) => void, fromIp: string }[] = [];\n"]]},{"start1":7656,"length1":13,"diffs":[[1,""]]},{"start1":7783,"length1":33,"diffs":[[1,""]]}]},{"type":"edited","filename":"multidevsettings.ts","patch":[{"start1":0,"length1":526,"diffs":[[1,"// Add your code here\n"]]}]}]},{"timestamp":1753993369724,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":86,"length1":0,"diffs":[[1,"    let fromip = \"\";\n"]]},{"start1":692,"length1":45,"diffs":[[1,"        then(fn: (value: T, fromIp?: string) => void): void {\n"]]},{"start1":843,"length1":32,"diffs":[[1,"                fn(this.value,fromip);\n"]]},{"start1":1199,"length1":77,"diffs":[[1,"    let waitForData: { func: (dat: string,ip:string) => void, fromIp: string }[] = [];\n"]]},{"start1":7851,"length1":0,"diffs":[[1,"                    fromip = ip;\n"]]}]},{"type":"edited","filename":"multidevsettings.ts","patch":[{"start1":21,"length1":880,"diffs":[[1,"    let permissions:Map<string,string> = new Map()\n    NetWorking.WaitForData(\"*\").then(function(a) {\n\n"]]},{"start1":251,"length1":50,"diffs":[[1,"    export function readRemoteStringFile(name:string) {\n"]]},{"start1":323,"length1":65,"diffs":[[1,"     * Give Permission for a Remote IP to read file `filename`\n"]]},{"start1":393,"length1":85,"diffs":[[1,"    export function addPermison(device_ip:string,filename:string) {\n       permissions = permissions.set(device_ip,filename);\n"]]}]}]},{"timestamp":1753993969139,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":123,"diffs":[[1,"NetWorking.myIP = \"10.0.0\"\nNetWorking.mySerial = 0;\nNetWorking.GetPeers().then(function(a) {\n"]]},{"start1":112,"length1":2,"diffs":[[1,"})\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1154,"length1":88,"diffs":[[1,"    let waitForData: { func: (dat: string) => void, fromIp: string }[] = [];\n"]]},{"start1":2831,"length1":245,"diffs":[[1,"                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? a.func(data) : false)\n"]]},{"start1":7325,"length1":61,"diffs":[[1,"    export function WaitForData(fromIp: string) {\n"]]},{"start1":7796,"length1":38,"diffs":[[1,"                }, fromIp: fromIp\n"]]}]},{"type":"edited","filename":"multidevsettings.ts","patch":[{"start1":21,"length1":236,"diffs":[[1,"    let permissions:string[] = []\n    let waitingForFiles:{filename:string,handler:(filecontents:string) => void}[] = [];\n    NetWorking.WaitForData(\"*\").then(function(a:string) {\n         if (a.startsWith(\"readfile|\")) {\n"]]},{"start1":381,"length1":87,"diffs":[[1,"               NetWorking.SendDataTo(ip,`file|${file}|${settings.readString(file)}`)\n"]]},{"start1":480,"length1":204,"diffs":[[1,"         }\n         if (a.startsWith(\"file|\")) {\n             let valid = null;\n             let name = a.split(\"|\")[1]\n             let contents = a.split(\"|\")[2]\n             for (let a of waitingForFiles) {\n"]]},{"start1":794,"length1":39,"diffs":[[1,"             }\n             if (valid) {\n"]]},{"start1":875,"length1":54,"diffs":[[1,"             }\n         }\n"]]},{"start1":916,"length1":910,"diffs":[[1,"     * Get the String file from a remote device , will return null if fails or does not have permission\n"]]},{"start1":1028,"length1":87,"diffs":[[1,"    export function readRemoteFile(name:string) {\n\n"]]},{"start1":1085,"length1":0,"diffs":[[1,"    /** \n     * Give Permission for any Remote IP to read file `filename`\n    */\n    export function addPermison(filename:string) {\n       permissions.push(filename)\n    }\n"]]}]}]},{"timestamp":1753994573606,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,"radio.sendString(\"\")\n"]]}]}]},{"timestamp":1753994607643,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\nsettings.writeString(\"data2.0\",NetWorking.myIP)\nsettings.readRemoteFile(\"data2.0\").then(function(a) {\n    console.log(a)\n})"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1543,"length1":46,"diffs":[[1,""]]},{"start1":3780,"length1":1191,"diffs":[[1,""]]},{"start1":3781,"length1":437,"diffs":[[1,""]]}]}]},{"timestamp":1753995194381,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":28,"diffs":[[1,""]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":899,"length1":210,"diffs":[[1,"    export let myIP = `10.${control.deviceSerialNumber() % 9}.${control.deviceSerialNumber() % 999}`;\n"]]},{"start1":1154,"length1":90,"diffs":[[1,"    let waitForData: { func: (dat: string) => void, fromIp: string,_?:boolean }[] = [];\n"]]},{"start1":1436,"length1":108,"diffs":[[1,"    radio2.onReceivedString(function (msg: string,packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n"]]},{"start1":1580,"length1":1,"diffs":[[1,"        \n"]]},{"start1":2469,"length1":168,"diffs":[[1,"                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return;}\n"]]},{"start1":3157,"length1":14,"diffs":[[1,"    },true);\n"]]},{"start1":5339,"length1":120,"diffs":[[1," * \n * NetWorking.restart();\n"]]},{"start1":5379,"length1":0,"diffs":[[1,"\n"]]},{"start1":9084,"length1":63,"diffs":[[1,"    export function WaitForData(fromIp: string,_?:boolean) {\n"]]},{"start1":9426,"length1":1,"diffs":[[1,"            \n"]]},{"start1":9566,"length1":40,"diffs":[[1,"                }, fromIp: fromIp,_:_\n"]]}]}]},{"timestamp":1753995704471,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":576,"diffs":[[1,"console.log(NetWorking.myIP)"]]}]}]},{"timestamp":1753996303185,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":31,"diffs":[[1,""]]},{"start1":148,"length1":12,"diffs":[[1,"\r\n"]]},{"start1":270,"length1":47,"diffs":[[1,""]]},{"start1":416,"length1":369,"diffs":[[1,""]]},{"start1":453,"length1":61,"diffs":[[1,"    scene.backgroundImage().printCenter(t.toString(), 50);\r\n"]]},{"start1":530,"length1":16,"diffs":[[1,"\r\nconsole.log(`Times before collision: ${t}`);"]]}]}]},{"timestamp":1753997194529,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\r\nfunction a(limit?:number) {\r\nlet ids: string[] = [];\r\nlet t = 0;\r\n\r\n// Use Math.random for pseudo-random generation\r\nfunction d(): number {\r\n    return randint(0,0xFFFFFFF)\r\n}\r\nlet _ = 0;\r\nwhile (true) {\r\n    let Id = `${((d() & 0xF) * 10) & 0xFF}.${d() & 0xFF}.${(d() >> 8) % 255}.${(d() >> 16) & 0xFF}`;\r\n\r\n    if (t > limit) {\r\n        break;\r\n    }\r\n\r\n    if (ids.indexOf(Id) !== -1) {\r\n        break; // Collision detected\r\n    }\r\n\r\n    ids.push(Id);\r\n    t++;\r\n\r\n    // Optional visual feedback\r\n    _++;\r\n    if (false) {\r\n        _ = 0\r\n        scene.backgroundImage().fill(0)\r\n        scene.backgroundImage().printCenter(t.toString(), 50);\r\n        pause(0)\r\n    }\r\n}\r\n\r\n//console.log(`Times before collision: ${t}`);\r\nreturn t;\r\n}\r\nlet min = Infinity;\r\nlet goal = 300000;\r\nlet o = true;\r\nlet _a = 0;\r\nwhile (o) {\r\n    min = a()\r\n    _a++;\r\n    o = min < goal;\r\n    scene.backgroundImage().fill(0)\r\n    scene.backgroundImage().printCenter(_a.toString(), 50);\r\n    pause(0)\r\n}\r\nconsole.log(min)"]]}]}]},{"timestamp":1754513621392,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":4,"diffs":[[1,""]]}]}]},{"timestamp":1754513622160,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":490,"diffs":[[1,"\r\n\r\n"]]}]}]},{"timestamp":1754530684657,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":32,"diffs":[[1,"//NetWorking.UseDNSCache = true;\r\n"]]}]}]},{"timestamp":1754530709967,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":65,"length1":232,"diffs":[[1,""]]},{"start1":98,"length1":44,"diffs":[[1,"    NetWorking.SendDataTo(\"10.0.0.0\", \"012345678901234567890123456789012345678901234567890123456789\")\r\n"]]},{"start1":234,"length1":71,"diffs":[[1,"console.log(`${500 * 60} bytes delivered in ${end - start} micros.`)\r\n"]]},{"start1":330,"length1":27,"diffs":[[1,"const amount = 500 * 60;\r\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":8024,"length1":85,"diffs":[[1,""]]},{"start1":9275,"length1":7,"diffs":[[1,""]]}]}]},{"timestamp":1754531692757,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1353,"length1":32,"diffs":[[1,"    radio.setFrequencyBand(0);\n"]]}]}]},{"timestamp":1754531733397,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":1385,"length1":93,"diffs":[[1,"    radio.setGroup(1); // this is passed to the low-level stuff , not the orignal radio.ts\n"]]},{"start1":3323,"length1":90,"diffs":[[1,"        if (game.runtime() - lastDiscoveryTime > 500 && findingDevices && foundDevices) {\n"]]}]}]},{"timestamp":1754532449545,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dns.ts","patch":[{"start1":2350,"length1":63,"diffs":[[1,"            radio2.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n"]]}]}]},{"timestamp":1754532581823,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":568,"length1":99,"diffs":[[1,"console.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,4)}`)"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":2060,"length1":65,"diffs":[[1,"        if (cmd === \"PEER\" && ip === \"*\" && parts[2] === \"FIND\") {\n"]]},{"start1":2254,"length1":41,"diffs":[[1,"        if (cmd == \"whois\" && ip == myIP) {\n"]]},{"start1":2424,"length1":34,"diffs":[[1,"        if (cmd == \"answer\" && ip) {\n"]]},{"start1":2895,"length1":27,"diffs":[[1,"        if (cmd == \"data\") {\n"]]},{"start1":6516,"length1":66,"diffs":[[1,"            radio2.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n"]]},{"start1":8024,"length1":85,"diffs":[[1,"     * @note apromxaltly 224 bytes of data can be sent before truncating will happen\n"]]},{"start1":8219,"length1":78,"diffs":[[1,"            radio2.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n"]]},{"start1":10336,"length1":63,"diffs":[[1,"                    radio2.sendString(`PEER:*|${mySerial}|FIND`)\n"]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":9970,"length1":5,"diffs":[[1,"\n"]]},{"start1":10798,"length1":54,"diffs":[[1,"        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n"]]}]}]},{"timestamp":1754533304219,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":568,"length1":96,"diffs":[[1,"console.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,4)}`)\r\n"]]}]}]},{"timestamp":1754533395443,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":297,"length1":36,"diffs":[[1,"for (let i = 0; i < 500; i++) {\r\n"]]},{"start1":407,"length1":72,"diffs":[[1,"console.log(`${500 * 224} bytes delivered in ${end - start} micros.`)\r\n"]]},{"start1":504,"length1":28,"diffs":[[1,"const amount = 500 * 224;\r\n"]]},{"start1":568,"length1":98,"diffs":[[1,"console.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,)}`)\r\n"]]}]}]},{"timestamp":1754593522935,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":573,"length1":18,"diffs":[[1,""]]}]}]},{"timestamp":1754593533366,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":573,"length1":59,"diffs":[[1,"console.log(``1)\r\n"]]}]}]},{"timestamp":1755393435976,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"NetWorking.UseDNSCache = true;\r\nconst start = control.micros();\r\n// Create a buffer of 224 bytes\r\nlet payload = control.createBuffer(224)\r\n\r\n// Fill it with a repeated value, e.g., 0xAA\r\nfor (let i = 0; i < payload.length; i++) {\r\n    payload.setUint8(i, 0xAA)\r\n}\r\nconst str = payload.toString()\r\n\r\nfor (let i = 0; i < 1000; i++) {\r\n    NetWorking.SendDataTo(\"10.0.0.0\", str)\r\n}\r\nconst end = control.micros()\r\nconsole.log(`${1000 * 224} bytes delivered in ${end - start} micros.`)\r\nconst len = end - start;\r\nconst amount = 1000 * 224;\r\nconst bytespermicro = amount / len;\r\nconsole.log(`bits/millisecond:${(bytespermicro*8)*1000}`)\r\nconsole.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,16)}`)\r\n\r\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":378,"length1":49,"diffs":[[1,"        \"multidevsettings.ts\"\n"]]}]},{"type":"edited","filename":"dns.ts","patch":[{"start1":1352,"length1":30,"diffs":[[1,""]]},{"start1":2049,"length1":89,"diffs":[[1,""]]},{"start1":2241,"length1":55,"diffs":[[1,""]]},{"start1":2945,"length1":746,"diffs":[[1,"                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? data.startsWith(\"file|\") || data.startsWith(\"readfile\") && !a._ ? false : a.func(data) : false)\n"]]},{"start1":3312,"length1":90,"diffs":[[1,"        if (game.runtime() - lastDiscoveryTime > 200 && findingDevices && foundDevices) {\n"]]},{"start1":4630,"length1":83,"diffs":[[1,"            pause(100) // make sure it is on.\n"]]},{"start1":6506,"length1":0,"diffs":[[1,"            radio2.sendString(\"wi:\" + ipTarget + \"|\" + mySerial);\n"]]},{"start1":6573,"length1":127,"diffs":[[1,""]]},{"start1":6833,"length1":80,"diffs":[[1,"                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n"]]},{"start1":7919,"length1":32,"diffs":[[1,""]]},{"start1":8206,"length1":221,"diffs":[[1,"            radio2.sendString(`dt:${ip}|${mySerial}|${JSON.stringify(data)}`)\n"]]},{"start1":10094,"length1":58,"diffs":[[1,"        return new Promise(function (resolve) {\n"]]},{"start1":10384,"length1":29,"diffs":[[1,"                    pause(10)\n"]]}]},{"type":"edited","filename":"radio2.ts","patch":[{"start1":11660,"length1":61,"diffs":[[1,"    function getMaxStringLength(packetType: number) {\n"]]}]},{"type":"edited","filename":"multidevsettings.ts","patch":[{"start1":56,"length1":183,"diffs":[[1,"    let waitingForFiles: { filename: string, handler: (filecontents: string) => void }[] = [];\n    NetWorking.WaitForData(\"*\",true).then(function (a: string) {\n"]]},{"start1":395,"length1":90,"diffs":[[1,"                NetWorking.SendDataTo(ip, `file|${file}|${settings.readString(file)}`)\n"]]},{"start1":612,"length1":84,"diffs":[[1,"            let contents = a.split(\"|\")[2]\n"]]},{"start1":818,"length1":297,"diffs":[[1,"            if (valid) {\n                valid.handler(contents)\n                valid = null;\n"]]},{"start1":1102,"length1":109,"diffs":[[1," * The file must be granted permission via `addPermission`, or the request will silently fail.\n"]]},{"start1":1374,"length1":64,"diffs":[[1,"        return new Promise<string>(function (resolve) {\n"]]},{"start1":1559,"length1":69,"diffs":[[1,"                }\n"]]}]},{"type":"added","filename":"test.ts","value":"NetWorking.UseDNSCache = true;\nNetWorking.init()\npause(randint(500,1900))\nconsole.log(`DEVICE SERIAL:${NetWorking.mySerial}`)\nconst start = control.micros();\n// Create a buffer of 223 bytes\nlet payload = control.createBuffer(223)\n\n// Fill it with a repeated value, e.g., 0xAA\npayload.fill(0xAA)\n\nconst str = payload.toString()\n\nfor (let i = 0; i < 150; i++) {\n    NetWorking.SendDataTo(\"10.0.0.0\", str)\n}\nconst end = control.micros()\nconsole.log(`${(150 * 223) / 1024} bytes delivered in ${end - start} micros.`)\nconsole.log(`Predicted Time for Trnamit:${((150 * 223) / 1024) / 8} Seconds.`)\nconst len = end - start;\nconst amount = 150 * 223;\nconst bytespermicro = amount / len;\nconsole.log(`bits/millisecond:${(bytespermicro * 8) * 1000}`)\nconsole.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024, 16)}`)\n\n"}]},{"timestamp":1759442322619,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {\" line1=\"    console.log(a)\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>"]]}]}]},{"timestamp":1759442383254,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":434,"length1":44,"diffs":[[1,""]]}]}]}],"snapshots":[{"timestamp":1753556188218,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1753572411244,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"NetWorking_sendWhoIs\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"267\" y=\"151\"><value name=\"ipTarget\"><shadow type=\"text\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"TEXT\"></field></shadow></value></block></xml>","main.ts":"NetWorking.UseDNSCache = false // enable caching\r\n\r\nlet t1 = control.micros()\r\nconsole.log(\"Started WaitForData at micros: \" + t1)\r\nlet a = 0\r\nNetWorking.WaitForData(\"10.0.100\").then(function (d) {\r\n    if (a > 20) return;\r\n    let t2 = control.micros()\r\n    console.log(\"Received data at micros: \" + t2)\r\n    console.log(\"WaitForData duration: \" + (t2 - t1) + \" µs\")\r\n    console.log(\"Received: \" + d)\r\n\r\n    pause(100) // simulate delay before sending\r\n\r\n    let t3 = control.micros()\r\n    console.log(\"Started SendDataTo at micros: \" + t3)\r\n\r\n    NetWorking.SendDataTo(\"10.0.100\", \"Hello\")\r\n\r\n    let t4 = control.micros()\r\n    console.log(\"SendDataTo completed at micros: \" + t4)\r\n    console.log(\"SendDataTo duration: \" + (t4 - t3) + \" µs\")\r\n    console.log(\"Total time from WaitForData start to Send complete: \" + (t4 - t1) + \" µs\")\r\n    a++\r\n})\r\n\r\nNetWorking.SendDataTo(\"10.0.100\",\"--start--\")","README.md":" ","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = \"10.0.100\";\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string }[] = [];\n\n    radio.setGroup(1);\n    radio.setTransmitPower(7);\n\n    radio2.onReceivedString(function (msg: string) {\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"whois\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"answer\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"data\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip ? a.func(data) : false)\n            }\n        }\n    });\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n                \n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler = \n            function(n:number) {\n                if (UseDNSCache) addMapping(ipTarget,n)\n                resolve(n);\n            }\n\n            radio2.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /**\n * Registers a data handler for incoming packets from a specific IP.\n * Multiple handlers can be added for the same IP; each will receive its own callback.\n * Use `.then()` on the returned Handler object to define what happens when data is received.\n *\n * @param fromIp - The IP address to listen for incoming data packets.\n * @returns A Handler that invokes the registered callback with the received data.\n */\n    export function WaitForData(fromIp: string) {\n        return new Handler<string>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    resolve(dat);\n                }, fromIp: fromIp\n            })\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n\n    export function safeParse(input: string, maxDepth: number = 5): any {\n        function tryParse(node: any, depth: number): any {\n            if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n            if (typeof node === \"string\") {\n                if (node.indexOf(\"{\") >= 0 || node.indexOf(\"[\") >= 0) {\n                    try {\n                        let parsed = JSON.parse(node);\n                        return tryParse(parsed, depth + 1); // recurse deeper\n                    } catch {\n                        return node; // not actual JSON, just a string\n                    }\n                }\n                return node;\n            }\n\n            if (Array.isArray(node)) {\n                let result = [];\n                for (let i = 0; i < node.length; i++) {\n                    result.push(tryParse(node[i], depth + 1));\n                }\n                return result;\n            }\n\n            if (typeof node === \"object\" && node !== null) {\n                let keys = Object.keys(node);\n                let result: any = {};\n                for (let i = 0; i < keys.length; i++) {\n                    let key = keys[i];\n                    result[key] = tryParse(node[key], depth + 1);\n                }\n                return result;\n            }\n\n            return node;\n        }\n\n        try {\n            let initial = JSON.parse(input);\n            return tryParse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 128;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 100;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    let transmittingSerial: boolean;\n    let initialized = false;\n\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    //% blockId=radio_on_number_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=20\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    //% blockId=radio_on_value_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=19\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    //% blockId=radio_on_string_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=18\n    export function onReceivedString(cb: (receivedString: string) => void) {\n        init();\n        onReceivedStringHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    //% blockId=radio_on_buffer_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    //% blockGap=8\n    //% blockId=radio_received_packet block=\"received packet %type=radio_packet_property\" blockGap=16\n    //% group=\"Receive\"\n    //% weight=16\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    //% weight=60\n    //% blockId=radio_datagram_send block=\"radio send number %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    //% weight=59\n    //% blockId=radio_datagram_send_value block=\"radio send|value %name|= %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    //% weight=58\n    //% blockId=radio_datagram_send_string block=\"radio send string %msg\"\n    //% msg.shadowOptions.toString=true\n    //% group=\"Send\"\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    //% weight=57\n    //% advanced=true\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    /**\n    * Set the radio to transmit the serial number in each message.\n    * @param transmit value indicating if the serial number is transmitted, eg: true\n    */\n    //% help=radio/set-transmit-serial-number\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_transmit_serial_number block=\"radio set transmit serial number %transmit\"\n    //% advanced=true\n    export function setTransmitSerialNumber(transmit: boolean) {\n        transmittingSerial = transmit;\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753646115999,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"NetWorking_sendWhoIs\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"267\" y=\"151\"><value name=\"ipTarget\"><shadow type=\"text\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"TEXT\"></field></shadow></value></block></xml>","main.ts":"NetWorking.SendDataTo(\"10.0.100\",\"----\")\r\nNetWorking.WaitForData(\"*\").then(function(str) {\r\n    console.log(`Recived:${str}`)\r\n})\r\npause(3000)\r\nNetWorking.GetPeers().then(function(a:string[]) {\r\nconsole.log(JSON.stringify(a))\r\n    NetWorking.SendDataTo(a[0], {\r\n        \"id\": \"device-42\",\r\n        \"temp\": 22.5,\r\n        \"humidity\": 58,\r\n        \"battery\": 3.7\r\n    })\r\n})\r\nconsole.log(control.deviceSerialNumber())","README.md":" ","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `10.${control.deviceSerialNumber() % 9}.${control.deviceSerialNumber() % 999}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string }[] = [];\n\n    radio.setFrequencyBand(0);\n    radio.setGroup(1); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"PEER\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"whois\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"answer\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"data\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? a.func(data) : false)\n            }\n        }\n    },true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 500 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n */\n    export function WaitForData(fromIp: string) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`PEER:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    let transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    //% blockId=radio_on_number_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=20\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    //% blockId=radio_on_value_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=19\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    //% blockId=radio_on_string_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=18\n    export function onReceivedString(cb: (receivedString: string) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    //% blockId=radio_on_buffer_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    //% blockGap=8\n    //% blockId=radio_received_packet block=\"received packet %type=radio_packet_property\" blockGap=16\n    //% group=\"Receive\"\n    //% weight=16\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    //% weight=60\n    //% blockId=radio_datagram_send block=\"radio send number %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    //% weight=59\n    //% blockId=radio_datagram_send_value block=\"radio send|value %name|= %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    //% weight=58\n    //% blockId=radio_datagram_send_string block=\"radio send string %msg\"\n    //% msg.shadowOptions.toString=true\n    //% group=\"Send\"\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    //% weight=57\n    //% advanced=true\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    /**\n    * Set the radio to transmit the serial number in each message.\n    * @param transmit value indicating if the serial number is transmitted, eg: true\n    */\n    //% help=radio/set-transmit-serial-number\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_transmit_serial_number block=\"radio set transmit serial number %transmit\"\n    //% advanced=true\n    export function setTransmitSerialNumber(transmit: boolean) {\n        transmittingSerial = true;\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1753905682490,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {&#13;\" line1=\"    console.log(a)&#13;\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"","README.md":"# makecode-DNS\r\n","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `10.${control.deviceSerialNumber() % 9}.${control.deviceSerialNumber() % 999}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string }[] = [];\n\n    radio.setFrequencyBand(0);\n    radio.setGroup(1); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string,packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"PEER\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"whois\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"answer\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return;}\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"data\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? a.func(data) : false)\n            }\n        }\n    },true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 500 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    //%block\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    //%block\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n    */\n    //%block\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    //%block\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n */\n    //%block\n    export function WaitForData(fromIp: string) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    //%block\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`PEER:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    const transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string,packet:RadioPacket) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload,lastPacket);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    //% blockId=radio_on_number_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=20\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    //% blockId=radio_on_value_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=19\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    //% blockId=radio_on_string_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    //% group=\"Receive\"\n    //% weight=18\n    export function onReceivedString(cb: (receivedString: string,packet:RadioPacket) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    //% blockId=radio_on_buffer_drag block=\"on radio received\" blockGap=16\n    //% useLoc=\"radio.onDataPacketReceived\" draggableParameters=reporter\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    //% blockGap=8\n    //% blockId=radio_received_packet block=\"received packet %type=radio_packet_property\" blockGap=16\n    //% group=\"Receive\"\n    //% weight=16\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    //% weight=60\n    //% blockId=radio_datagram_send block=\"radio send number %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    //% weight=59\n    //% blockId=radio_datagram_send_value block=\"radio send|value %name|= %value\" blockGap=8\n    //% group=\"Send\"\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    //% weight=58\n    //% blockId=radio_datagram_send_string block=\"radio send string %msg\"\n    //% msg.shadowOptions.toString=true\n    //% group=\"Send\"\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    //% weight=57\n    //% advanced=true\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1753996417592,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {\" line1=\"    console.log(a)\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"let ids: string[] = [];\r\nlet t = 0;\r\n\r\n// Use Math.random for pseudo-random generation\r\nfunction d(): number {\r\n    return randint(0,0xFFFFFFF)\r\n}\r\nlet _ = 0;\r\nwhile (true) {\r\n    let Id = `${((d() & 0xF) * 10) & 0xFF}.${d() & 0xFF}.${(d() >> 8) % 255}.${(d() >> 16) & 0xFF}`;\r\n\r\n    if (ids.indexOf(Id) !== -1) {\r\n        break; // Collision detected\r\n    }\r\n\r\n    ids.push(Id);\r\n    t++;\r\n\r\n    // Optional visual feedback\r\n    _++;\r\n    if (_ > 80) {\r\n        _ = 0\r\n        scene.backgroundImage().fill(0)\r\n        scene.backgroundImage().printCenter(t.toString(), 50);\r\n        pause(0)\r\n    }\r\n}\r\n\r\nconsole.log(`Times before collision: ${t}`);","README.md":"# makecode-DNS\r\n","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `${((control.deviceSerialNumber() & 0xF) * 10) & 0xFF}.${control.deviceSerialNumber() & 0xFF}.${(control.deviceSerialNumber() >> 8) % 255}.${(control.deviceSerialNumber() >> 16) & 0xFF}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string, _?: boolean }[] = [];\n\n    radio.setFrequencyBand(0);\n    radio.setGroup(1); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string, packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        if (msg == \"ignore\") return;\n\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"PEER\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"whois\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"answer\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return; }\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"data\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? data.startsWith(\"file|\") || data.startsWith(\"readfile\") && !a._ ? false : a.func(data) : false)\n            }\n        }\n    }, true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 500 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n    /**\n * Initializes the radio communication subsystem.\n * Handles both simulation and hardware contexts by waking up the radio module.\n * Must be called before any networking operations are performed.\n *\n * - In simulation mode: sends a dummy packet and waits briefly for readiness.\n * - On hardware: powers up the radio and delays to ensure full activation.\n */\n    export function init() {\n        let inSim = control.deviceDalVersion() == \"sim\"\n        if (inSim) {\n            radio2.sendString(\"ignore\") // needed to wake up radio.\n            pause(10) // make sure the radio is ready.\n        } else {\n            radio.on()\n            radio2.sendString(\"ignore\") // just to make sure radio is on.\n            pause(100) // make sure it is on.\n        }\n    }\n    /**\n     * Gracefully shuts down the radio system and clears internal network state.\n     * Removes any active listeners and disables the radio hardware.\n     * Call this before putting the system to sleep or ending a session.\n     */\n    export function shutdown() {\n        responseHandler = null;\n        waitForData = null;\n        waitingForResponse = false;\n        waitForData = [];\n        radio.off()\n    }\n\n    /**\n * Provides a clean way to reboot the radio subsystem, resetting communication state.\n * Intended for scenarios where a fresh connection lifecycle is desirable — such as transitioning between sessions,\n * reinitializing after inactivity, or recovering from undefined networking behavior.\n *\n * Example:\n * ``` ts\n * function run() {\n *  handlegameLogic();\n *  NetWorking.restart(); // restart the radio and try again\n *  run();\n * }\n * ```\n */\n    export function restart() {\n        shutdown();\n        init();\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n */\n    export function WaitForData(fromIp: string, _?: boolean) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp, _: _\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`PEER:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    const transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string,packet:RadioPacket) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload,lastPacket);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    export function onReceivedString(cb: (receivedString: string,packet:RadioPacket) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","multidevsettings.ts":"namespace settings {\n    let permissions: string[] = []\n    let waitingForFiles: { filename: string, handler: (filecontents: string) => void }[] = [];\n    NetWorking.WaitForData(\"*\",true).then(function (a: string) {\n        if (a.startsWith(\"readfile|\")) {\n            let file = a.split(\"|\")[1]\n            let ip = a.split(\"|\")[2]\n            if (permissions.includes(file) && exists(file)) {\n                NetWorking.SendDataTo(ip, `file|${file}|${settings.readString(file)}`)\n            }\n        }\n        if (a.startsWith(\"file|\")) {\n            let valid = null;\n            let name = a.split(\"|\")[1]\n            let contents = a.split(\"|\")[2]\n            for (let a of waitingForFiles) {\n                if (a.filename == name && a.handler) {\n                    valid = a;\n                }\n            }\n            if (valid) {\n                valid.handler(contents)\n                valid = null;\n            }\n        }\n    })\n    /**\n * Requests a string file from a remote device over the network.\n * Returns a Promise that resolves with the file contents if successfully retrieved.\n * The file must be granted permission via `addPermission`, or the request will silently fail.\n *\n * @param name - The name of the file to retrieve\n * @returns Promise that resolves with the file contents as a string\n */\n    export function readRemoteFile(name: string) {\n        return new Promise<string>(function (resolve) {\n            waitingForFiles.push({\n                filename: name, handler: function (a) {\n                    if (a) resolve(a)\n                }\n            })\n        })\n    }\n\n    /**\n     * Grants permission for any remote IP to request the specified file.\n     * Once granted, requests to this file will be responded to with its contents (if it exists).\n     *\n     * @param filename - The name of the file to allow access to\n     */\n    export function addPermison(filename: string) {\n        permissions.push(filename)\n    }\n}","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\",\n        \"multidevsettings.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1754513621392,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {\" line1=\"    console.log(a)\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"\r\nfunction a(limit?:number) {\r\nlet ids: string[] = [];\r\nlet t = 0;\r\n\r\n// Use Math.random for pseudo-random generation\r\nfunction d(): number {\r\n    return randint(0,0xFFFFFFF)\r\n}\r\nlet _ = 0;\r\nwhile (true) {\r\n    let Id = `${((d() & 0xF) * 10) & 0xFF}.${d() & 0xFF}.${(d() >> 8) % 255}.${(d() >> 16) & 0xFF}`;\r\n\r\n    if (t > limit) {\r\n        break;\r\n    }\r\n\r\n    if (ids.indexOf(Id) !== -1) {\r\n        break; // Collision detected\r\n    }\r\n\r\n    ids.push(Id);\r\n    t++;\r\n\r\n    // Optional visual feedback\r\n    _++;\r\n    if (false) {\r\n        _ = 0\r\n        scene.backgroundImage().fill(0)\r\n        scene.backgroundImage().printCenter(t.toString(), 50);\r\n        pause(0)\r\n    }\r\n}\r\n\r\n//console.log(`Times before collision: ${t}`);\r\nreturn t;\r\n}\r\nlet min = Infinity;\r\nlet goal = 300000;\r\nlet o = true;\r\nlet _a = 0;\r\nwhile (o) {\r\n    min = a()\r\n    _a++;\r\n    o = min < goal;\r\n    scene.backgroundImage().fill(0)\r\n    scene.backgroundImage().printCenter(_a.toString(), 50);\r\n    pause(0)\r\n}\r\nconsole.log(min)","README.md":"# makecode-DNS\r\n","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `${((control.deviceSerialNumber() & 0xF) * 10) & 0xFF}.${control.deviceSerialNumber() & 0xFF}.${(control.deviceSerialNumber() >> 8) % 255}.${(control.deviceSerialNumber() >> 16) & 0xFF}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string, _?: boolean }[] = [];\n\n    radio.setFrequencyBand(0);\n    radio.setGroup(1); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string, packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        if (msg == \"ignore\") return;\n\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"PEER\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"whois\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"answer:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"answer\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return; }\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"data\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? data.startsWith(\"file|\") || data.startsWith(\"readfile\") && !a._ ? false : a.func(data) : false)\n            }\n        }\n    }, true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 500 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n    /**\n * Initializes the radio communication subsystem.\n * Handles both simulation and hardware contexts by waking up the radio module.\n * Must be called before any networking operations are performed.\n *\n * - In simulation mode: sends a dummy packet and waits briefly for readiness.\n * - On hardware: powers up the radio and delays to ensure full activation.\n */\n    export function init() {\n        let inSim = control.deviceDalVersion() == \"sim\"\n        if (inSim) {\n            radio2.sendString(\"ignore\") // needed to wake up radio.\n            pause(10) // make sure the radio is ready.\n        } else {\n            radio.on()\n            radio2.sendString(\"ignore\") // just to make sure radio is on.\n            pause(100) // make sure it is on.\n        }\n    }\n    /**\n     * Gracefully shuts down the radio system and clears internal network state.\n     * Removes any active listeners and disables the radio hardware.\n     * Call this before putting the system to sleep or ending a session.\n     */\n    export function shutdown() {\n        responseHandler = null;\n        waitForData = null;\n        waitingForResponse = false;\n        waitForData = [];\n        radio.off()\n    }\n\n    /**\n * Provides a clean way to reboot the radio subsystem, resetting communication state.\n * Intended for scenarios where a fresh connection lifecycle is desirable — such as transitioning between sessions,\n * reinitializing after inactivity, or recovering from undefined networking behavior.\n *\n * Example:\n * ``` ts\n * function run() {\n *  handlegameLogic();\n *  NetWorking.restart(); // restart the radio and try again\n *  run();\n * }\n * ```\n */\n    export function restart() {\n        shutdown();\n        init();\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"whois:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`data:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n */\n    export function WaitForData(fromIp: string, _?: boolean) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp, _: _\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`PEER:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    const transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string,packet:RadioPacket) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload,lastPacket);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    export function onReceivedString(cb: (receivedString: string,packet:RadioPacket) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = transmittingSerial ? control.deviceSerialNumber() : 0;\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","multidevsettings.ts":"namespace settings {\n    let permissions: string[] = []\n    let waitingForFiles: { filename: string, handler: (filecontents: string) => void }[] = [];\n    NetWorking.WaitForData(\"*\",true).then(function (a: string) {\n        if (a.startsWith(\"readfile|\")) {\n            let file = a.split(\"|\")[1]\n            let ip = a.split(\"|\")[2]\n            if (permissions.includes(file) && exists(file)) {\n                NetWorking.SendDataTo(ip, `file|${file}|${settings.readString(file)}`)\n            }\n        }\n        if (a.startsWith(\"file|\")) {\n            let valid = null;\n            let name = a.split(\"|\")[1]\n            let contents = a.split(\"|\")[2]\n            for (let a of waitingForFiles) {\n                if (a.filename == name && a.handler) {\n                    valid = a;\n                }\n            }\n            if (valid) {\n                valid.handler(contents)\n                valid = null;\n            }\n        }\n    })\n    /**\n * Requests a string file from a remote device over the network.\n * Returns a Promise that resolves with the file contents if successfully retrieved.\n * The file must be granted permission via `addPermission`, or the request will silently fail.\n *\n * @param name - The name of the file to retrieve\n * @returns Promise that resolves with the file contents as a string\n */\n    export function readRemoteFile(name: string) {\n        return new Promise<string>(function (resolve) {\n            waitingForFiles.push({\n                filename: name, handler: function (a) {\n                    if (a) resolve(a)\n                }\n            })\n        })\n    }\n\n    /**\n     * Grants permission for any remote IP to request the specified file.\n     * Once granted, requests to this file will be responded to with its contents (if it exists).\n     *\n     * @param filename - The name of the file to allow access to\n     */\n    export function addPermison(filename: string) {\n        permissions.push(filename)\n    }\n}","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\",\n        \"multidevsettings.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1754595994327,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {\" line1=\"    console.log(a)\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"NetWorking.UseDNSCache = true;\r\nconst start = control.micros();\r\n// Create a buffer of 224 bytes\r\nlet payload = control.createBuffer(224)\r\n\r\n// Fill it with a repeated value, e.g., 0xAA\r\nfor (let i = 0; i < payload.length; i++) {\r\n    payload.setUint8(i, 0xAA)\r\n}\r\nconst str = payload.toString()\r\n\r\nfor (let i = 0; i < 1000; i++) {\r\n    NetWorking.SendDataTo(\"10.0.0.0\", str)\r\n}\r\nconst end = control.micros()\r\nconsole.log(`${1000 * 224} bytes delivered in ${end - start} micros.`)\r\nconst len = end - start;\r\nconst amount = 1000 * 224;\r\nconst bytespermicro = amount / len;\r\nconsole.log(`bits/millisecond:${(bytespermicro*8)*1000}`)\r\nconsole.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,16)}`)\r\n\r\n","README.md":"# makecode-DNS\r\n","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `${((control.deviceSerialNumber() & 0xF) * 10) & 0xFF}.${control.deviceSerialNumber() & 0xFF}.${(control.deviceSerialNumber() >> 8) % 255}.${(control.deviceSerialNumber() >> 16) & 0xFF}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string, _?: boolean }[] = [];\n\n    radio.setFrequencyBand(40);\n    radio.setGroup(200); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string, packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        if (msg == \"ignore\") return;\n\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"pr\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"wi\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"ans:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"ans\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return; }\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"dt\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? data.startsWith(\"file|\") || data.startsWith(\"readfile\") && !a._ ? false : a.func(data) : false)\n            }\n        }\n    }, true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 200 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n    /**\n * Initializes the radio communication subsystem.\n * Handles both simulation and hardware contexts by waking up the radio module.\n * Must be called before any networking operations are performed.\n *\n * - In simulation mode: sends a dummy packet and waits briefly for readiness.\n * - On hardware: powers up the radio and delays to ensure full activation.\n */\n    export function init() {\n        let inSim = control.deviceDalVersion() == \"sim\"\n        if (inSim) {\n            radio2.sendString(\"ignore\") // needed to wake up radio.\n            pause(10) // make sure the radio is ready.\n        } else {\n            radio.on()\n            radio2.sendString(\"ignore\") // just to make sure radio is on.\n            pause(100) // make sure it is on.\n        }\n    }\n    /**\n     * Gracefully shuts down the radio system and clears internal network state.\n     * Removes any active listeners and disables the radio hardware.\n     * Call this before putting the system to sleep or ending a session.\n     */\n    export function shutdown() {\n        responseHandler = null;\n        waitForData = null;\n        waitingForResponse = false;\n        waitForData = [];\n        radio.off()\n    }\n\n    /**\n * Provides a clean way to reboot the radio subsystem, resetting communication state.\n * Intended for scenarios where a fresh connection lifecycle is desirable — such as transitioning between sessions,\n * reinitializing after inactivity, or recovering from undefined networking behavior.\n *\n * Example:\n * ``` ts\n * function run() {\n *  handlegameLogic();\n *  NetWorking.restart(); // restart the radio and try again\n *  run();\n * }\n * ```\n */\n    export function restart() {\n        shutdown();\n        init();\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"wi:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n     * @note apromxaltly 226 bytes of data can be sent before truncating will happen\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`dt:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n * \n *\n */\n    export function WaitForData(fromIp: string, _?: boolean) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp, _: _\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`pr:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    const transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string,packet:RadioPacket) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload,lastPacket);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    export function onReceivedString(cb: (receivedString: string,packet:RadioPacket) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n    \n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = control.deviceSerialNumber();\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","multidevsettings.ts":"namespace settings {\n    let permissions: string[] = []\n    let waitingForFiles: { filename: string, handler: (filecontents: string) => void }[] = [];\n    NetWorking.WaitForData(\"*\",true).then(function (a: string) {\n        if (a.startsWith(\"readfile|\")) {\n            let file = a.split(\"|\")[1]\n            let ip = a.split(\"|\")[2]\n            if (permissions.includes(file) && exists(file)) {\n                NetWorking.SendDataTo(ip, `file|${file}|${settings.readString(file)}`)\n            }\n        }\n        if (a.startsWith(\"file|\")) {\n            let valid = null;\n            let name = a.split(\"|\")[1]\n            let contents = a.split(\"|\")[2]\n            for (let a of waitingForFiles) {\n                if (a.filename == name && a.handler) {\n                    valid = a;\n                }\n            }\n            if (valid) {\n                valid.handler(contents)\n                valid = null;\n            }\n        }\n    })\n    /**\n * Requests a string file from a remote device over the network.\n * Returns a Promise that resolves with the file contents if successfully retrieved.\n * The file must be granted permission via `addPermission`, or the request will silently fail.\n *\n * @param name - The name of the file to retrieve\n * @returns Promise that resolves with the file contents as a string\n */\n    export function readRemoteFile(name: string) {\n        return new Promise<string>(function (resolve) {\n            waitingForFiles.push({\n                filename: name, handler: function (a) {\n                    if (a) resolve(a)\n                }\n            })\n        })\n    }\n\n    /**\n     * Grants permission for any remote IP to request the specified file.\n     * Once granted, requests to this file will be responded to with its contents (if it exists).\n     *\n     * @param filename - The name of the file to allow access to\n     */\n    export function addPermison(filename: string) {\n        permissions.push(filename)\n    }\n}","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\",\n        \"multidevsettings.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1755393435976,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {\" line1=\"    console.log(a)\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"NetWorking.UseDNSCache = true;\r\nconst start = control.micros();\r\n// Create a buffer of 224 bytes\r\nlet payload = control.createBuffer(224)\r\n\r\n// Fill it with a repeated value, e.g., 0xAA\r\nfor (let i = 0; i < payload.length; i++) {\r\n    payload.setUint8(i, 0xAA)\r\n}\r\nconst str = payload.toString()\r\n\r\nfor (let i = 0; i < 1000; i++) {\r\n    NetWorking.SendDataTo(\"10.0.0.0\", str)\r\n}\r\nconst end = control.micros()\r\nconsole.log(`${1000 * 224} bytes delivered in ${end - start} micros.`)\r\nconst len = end - start;\r\nconst amount = 1000 * 224;\r\nconst bytespermicro = amount / len;\r\nconsole.log(`bits/millisecond:${(bytespermicro*8)*1000}`)\r\nconsole.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,16)}`)\r\n\r\n","README.md":"# makecode-DNS\r\n","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `${((control.deviceSerialNumber() & 0xF) * 10) & 0xFF}.${control.deviceSerialNumber() & 0xFF}.${(control.deviceSerialNumber() >> 8) % 255}.${(control.deviceSerialNumber() >> 16) & 0xFF}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string, _?: boolean }[] = [];\n\n    radio.setFrequencyBand(40);\n    radio.setGroup(200); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string, packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        if (msg == \"ignore\") return;\n\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"pr\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"wi\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"ans:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"ans\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return; }\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"dt\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? data.startsWith(\"file|\") || data.startsWith(\"readfile\") && !a._ ? false : a.func(data) : false)\n            }\n        }\n    }, true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 200 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n    /**\n * Initializes the radio communication subsystem.\n * Handles both simulation and hardware contexts by waking up the radio module.\n * Must be called before any networking operations are performed.\n *\n * - In simulation mode: sends a dummy packet and waits briefly for readiness.\n * - On hardware: powers up the radio and delays to ensure full activation.\n */\n    export function init() {\n        let inSim = control.deviceDalVersion() == \"sim\"\n        if (inSim) {\n            radio2.sendString(\"ignore\") // needed to wake up radio.\n            pause(10) // make sure the radio is ready.\n        } else {\n            radio.on()\n            radio2.sendString(\"ignore\") // just to make sure radio is on.\n            pause(100) // make sure it is on.\n        }\n    }\n    /**\n     * Gracefully shuts down the radio system and clears internal network state.\n     * Removes any active listeners and disables the radio hardware.\n     * Call this before putting the system to sleep or ending a session.\n     */\n    export function shutdown() {\n        responseHandler = null;\n        waitForData = null;\n        waitingForResponse = false;\n        waitForData = [];\n        radio.off()\n    }\n\n    /**\n * Provides a clean way to reboot the radio subsystem, resetting communication state.\n * Intended for scenarios where a fresh connection lifecycle is desirable — such as transitioning between sessions,\n * reinitializing after inactivity, or recovering from undefined networking behavior.\n *\n * Example:\n * ``` ts\n * function run() {\n *  handlegameLogic();\n *  NetWorking.restart(); // restart the radio and try again\n *  run();\n * }\n * ```\n */\n    export function restart() {\n        shutdown();\n        init();\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"wi:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n     * @note apromxaltly 226 bytes of data can be sent before truncating will happen\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`dt:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n * \n *\n */\n    export function WaitForData(fromIp: string, _?: boolean) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp, _: _\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`pr:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    const transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string,packet:RadioPacket) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload,lastPacket);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    export function onReceivedString(cb: (receivedString: string,packet:RadioPacket) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n    \n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = control.deviceSerialNumber();\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","multidevsettings.ts":"namespace settings {\n    let permissions: string[] = []\n    let waitingForFiles: { filename: string, handler: (filecontents: string) => void }[] = [];\n    NetWorking.WaitForData(\"*\",true).then(function (a: string) {\n        if (a.startsWith(\"readfile|\")) {\n            let file = a.split(\"|\")[1]\n            let ip = a.split(\"|\")[2]\n            if (permissions.includes(file) && exists(file)) {\n                NetWorking.SendDataTo(ip, `file|${file}|${settings.readString(file)}`)\n            }\n        }\n        if (a.startsWith(\"file|\")) {\n            let valid = null;\n            let name = a.split(\"|\")[1]\n            let contents = a.split(\"|\")[2]\n            for (let a of waitingForFiles) {\n                if (a.filename == name && a.handler) {\n                    valid = a;\n                }\n            }\n            if (valid) {\n                valid.handler(contents)\n                valid = null;\n            }\n        }\n    })\n    /**\n * Requests a string file from a remote device over the network.\n * Returns a Promise that resolves with the file contents if successfully retrieved.\n * The file must be granted permission via `addPermission`, or the request will silently fail.\n *\n * @param name - The name of the file to retrieve\n * @returns Promise that resolves with the file contents as a string\n */\n    export function readRemoteFile(name: string) {\n        return new Promise<string>(function (resolve) {\n            waitingForFiles.push({\n                filename: name, handler: function (a) {\n                    if (a) resolve(a)\n                }\n            })\n        })\n    }\n\n    /**\n     * Grants permission for any remote IP to request the specified file.\n     * Once granted, requests to this file will be responded to with its contents (if it exists).\n     *\n     * @param filename - The name of the file to allow access to\n     */\n    export function addPermison(filename: string) {\n        permissions.push(filename)\n    }\n}","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\",\n        \"multidevsettings.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1759442322619,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.myIP = &quot;10.0.0&quot;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.mySerial = 0;\" numlines=\"1\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"NetWorking.GetPeers().then(function(a) {\" line1=\"    console.log(a)\" line2=\"})\" numlines=\"3\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"NetWorking.UseDNSCache = true;\r\nconst start = control.micros();\r\n// Create a buffer of 224 bytes\r\nlet payload = control.createBuffer(224)\r\n\r\n// Fill it with a repeated value, e.g., 0xAA\r\nfor (let i = 0; i < payload.length; i++) {\r\n    payload.setUint8(i, 0xAA)\r\n}\r\nconst str = payload.toString()\r\n\r\nfor (let i = 0; i < 1000; i++) {\r\n    NetWorking.SendDataTo(\"10.0.0.0\", str)\r\n}\r\nconst end = control.micros()\r\nconsole.log(`${1000 * 224} bytes delivered in ${end - start} micros.`)\r\nconst len = end - start;\r\nconst amount = 1000 * 224;\r\nconst bytespermicro = amount / len;\r\nconsole.log(`bits/millisecond:${(bytespermicro*8)*1000}`)\r\nconsole.log(`kb/second:${Math.roundWithPrecision((((bytespermicro) * 1000) * 1000) / 1024,16)}`)\r\n\r\n","README.md":"# makecode-DNS\r\n","assets.json":"","dns.ts":"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace NetWorking {\n    export class Handler<T> {\n        private callback: ((value: T) => void) | null = null;\n        private value: T | null = null;\n        private resolved: boolean = false;\n\n        constructor(exec: (resolve: (value: T) => void) => void) {\n            const internalResolve = (val: T) => {\n                this.value = val;\n                this.resolved = true;\n\n                if (this.callback) {\n                    this.callback(val);\n                }\n            };\n\n            control.runInParallel(() => {\n                exec(internalResolve);\n            });\n        }\n\n        then(fn: (value: T) => void): void {\n            this.callback = fn;\n\n            if (this.resolved && this.value !== null) {\n                fn(this.value);\n            }\n        }\n    }\n    type SerialNumber = number;\n    export let myIP = `${((control.deviceSerialNumber() & 0xF) * 10) & 0xFF}.${control.deviceSerialNumber() & 0xFF}.${(control.deviceSerialNumber() >> 8) % 255}.${(control.deviceSerialNumber() >> 16) & 0xFF}`;\n    export let mySerial = control.deviceSerialNumber();\n    let waitingForResponse = false;\n    let responseHandler: (rep: SerialNumber) => void = null;\n    let waitForData: { func: (dat: string) => void, fromIp: string, _?: boolean }[] = [];\n\n    radio.setFrequencyBand(40);\n    radio.setGroup(200); // this is passed to the low-level stuff , not the orignal radio.ts\n    radio.setTransmitPower(7); // and this is to the low-level stuff.\n\n    radio2.onReceivedString(function (msg: string, packet) { // radio.sendString(`PEER:*|${mySerial}|FIND`)\n        if (msg == \"ignore\") return;\n\n        let parts = msg.split(\"|\");\n        let cmdAndIp = parts[0].split(\":\");\n        let cmd = cmdAndIp[0];\n        let ip = cmdAndIp[1];\n        let replyTo = parts[1];\n\n        if (cmd == \"ap\" && findingDevices && found.indexOf(ip) == -1) {\n            found.push(ip);\n            lastDiscoveryTime = control.millis(); // Update discovery timestamp\n        }\n\n        if (cmd === \"pr\" && ip === \"*\" && parts[2] === \"FIND\") {\n            // Send back a response to the sender's serial\n            radio2.sendString(`ap:${myIP}|${mySerial}`);\n        }\n\n        if (cmd == \"wi\" && ip == myIP) {\n            // Respond directly to serial of sender\n            radio2.sendString(\"ans:\" + myIP + \"|\" + mySerial);\n        }\n\n        if (cmd == \"ans\" && ip) {\n            if (waitingForResponse && responseHandler) {\n                let senderSerial = parseInt(replyTo);\n                if (packet.serial !== senderSerial) { console.warn(`⚠️ Spoof Alert: IP ${ip} claims serial ${senderSerial}, but expected ${packet.serial}.`); return; }\n                responseHandler(senderSerial);\n                waitingForResponse = false;\n                responseHandler = null;\n            }\n        }\n        if (cmd == \"dt\") {\n            if (waitForData) {\n                let data = parts[2];\n                waitForData.forEach((a) => a.fromIp == ip || a.fromIp == \"*\" || a.fromIp.endsWith(\"*\") && ip.startsWith(a.fromIp.replace(\"*\", \"\")) ? data.startsWith(\"file|\") || data.startsWith(\"readfile\") && !a._ ? false : a.func(data) : false)\n            }\n        }\n    }, true);\n\n\n    game.onUpdateInterval(100, function () {\n        if (game.runtime() - lastDiscoveryTime > 200 && findingDevices && foundDevices) {\n            foundDevices(found);\n            foundDevices = null;\n            findingDevices = false;\n        }\n    })\n\n    const TTL_MS = 5000\n\n    function cleanCache() {\n        const now = game.runtime()\n        const keys = cache.keysArray()\n        const values = cache.valuesArray()\n\n        for (let i = 0; i < keys.length; i++) {\n            const ip = keys[i]\n            const entry = values[i]\n            if (now - entry.timestamp > TTL_MS) {\n                cache.delete(ip)\n            }\n        }\n    }\n    /**\n * Initializes the radio communication subsystem.\n * Handles both simulation and hardware contexts by waking up the radio module.\n * Must be called before any networking operations are performed.\n *\n * - In simulation mode: sends a dummy packet and waits briefly for readiness.\n * - On hardware: powers up the radio and delays to ensure full activation.\n */\n    export function init() {\n        let inSim = control.deviceDalVersion() == \"sim\"\n        if (inSim) {\n            radio2.sendString(\"ignore\") // needed to wake up radio.\n            pause(10) // make sure the radio is ready.\n        } else {\n            radio.on()\n            radio2.sendString(\"ignore\") // just to make sure radio is on.\n            pause(100) // make sure it is on.\n        }\n    }\n    /**\n     * Gracefully shuts down the radio system and clears internal network state.\n     * Removes any active listeners and disables the radio hardware.\n     * Call this before putting the system to sleep or ending a session.\n     */\n    export function shutdown() {\n        responseHandler = null;\n        waitForData = null;\n        waitingForResponse = false;\n        waitForData = [];\n        radio.off()\n    }\n\n    /**\n * Provides a clean way to reboot the radio subsystem, resetting communication state.\n * Intended for scenarios where a fresh connection lifecycle is desirable — such as transitioning between sessions,\n * reinitializing after inactivity, or recovering from undefined networking behavior.\n *\n * Example:\n * ``` ts\n * function run() {\n *  handlegameLogic();\n *  NetWorking.restart(); // restart the radio and try again\n *  run();\n * }\n * ```\n */\n    export function restart() {\n        shutdown();\n        init();\n    }\n\n    // Utility to send a whois query\n    /** \n     * Send a DNS request around about what is the serial number of the device with this ip?\n     * @param ipTarget the ip to request the serial number of.\n    */\n    export function sendWhoIs(ipTarget: string): Promise<SerialNumber> {\n        return new Promise<SerialNumber>(function (resolve, reject) {\n            if (UseDNSCache) {\n                cleanCache();\n\n                if (cache.has(ipTarget)) {\n                    let cached = cache.get(ipTarget);\n                    resolve(cached.serial);\n                    return; // Prevent sending a new query\n                }\n            }\n            waitingForResponse = true;\n            responseHandler =\n                function (n: number) {\n                    if (UseDNSCache) addMapping(ipTarget, n)\n                    resolve(n);\n                }\n\n            radio2.sendString(\"wi:\" + ipTarget + \"|\" + mySerial);\n\n            // Timeout: reject if no response in 5 sec\n            control.runInParallel(() => {\n                pause(5000);\n                if (waitingForResponse) {\n                    waitingForResponse = false;\n                    responseHandler = null;\n                    reject(\"ERR , TimeOut for DNS reached.\"); // Or use a custom error code/message\n                }\n            });\n        });\n    }\n    /** \n     * A Safer Stringify than JSON.stringify , Handles recusive objects.\n     * @param obj the Object to convert to a JSON string\n    */\n    export function safeStringify(obj: any, depth = 0, maxDepth = 10): string {\n        if (depth > maxDepth) throw '\"[Max depth reached]\"';\n\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n            return JSON.stringify(obj);\n        }\n\n        if (obj === null) return 'null';\n\n        if (Array.isArray(obj)) {\n            return '[' + obj.map((item: any) => safeStringify(item, depth + 1, maxDepth)).join(',') + ']';\n        }\n\n        if (typeof obj === 'object') {\n            let props = Object.keys(obj).map(key => {\n                return JSON.stringify(key) + ':' + safeStringify(obj[key], depth + 1, maxDepth);\n            });\n            return '{' + props.join(',') + '}';\n        }\n\n        throw '\"[Unserializable]\"';\n    }\n    /** \n     * Send a String of Data To a IP.\n     * @param ip the IP to send the data to.\n     * @note apromxaltly 226 bytes of data can be sent before truncating will happen\n    */\n    export function SendDataTo(ip: string, data: any) {\n        sendWhoIs(ip).then(function (serial) {\n            radio2.sendString(`dt:${ip}|${mySerial}|${JSON.stringify(data)}`)\n        })\n    }\n    /** \n     * Wether to Parse numbers and pas the parsed number if possible when a WaitForData Handler is ran\n    */\n    export let AUTO_PARSE_NUMBERS = false;\n    /**\n * Registers a data handler for incoming packets from a specific IP or IP pattern.\n * Supports wildcards to match multiple IPs:\n * - Use `\"*\"` to listen for data from any IP address.\n * - Use patterns like `\"10.*\"` to match all IPs starting with `10.` (e.g., `10.0.0.5`, `10.2.1.42`).\n * Multiple handlers can be added for the same or overlapping IP ranges.\n * \n * Note: JSON data will Not be Parsed befor being Passed to the Handler , if `NetWorking.AUTO_PARSE_NUMBERS` is set to true , then if the data recived is numeric,  the handler will be called with the parsed numeric value\n *  \n * Use `.then()` on the returned Handler object to define what happens when matching data is received.\n *\n * @param fromIp - The IP address or pattern to listen for. Supports `\"*\"` and prefix wildcards.\n * @returns A Handler that invokes the registered callback with the received data.\n * \n *\n */\n    export function WaitForData(fromIp: string, _?: boolean) {\n        return new Handler<string | number>(function (resolve) {\n            waitForData.push({\n                func: function (dat) {\n                    if (AUTO_PARSE_NUMBERS) {\n                        let parsed = parseFloat(dat);\n                        if (!isNaN(parsed)) {\n\n                            resolve(parsed);\n                        }\n                    }\n                    resolve(dat);\n                }, fromIp: fromIp, _: _\n            })\n        })\n    }\n    let findingDevices = false;\n    let foundDevices: (dev: string[]) => void = null;\n    let found: string[] = []\n    let lastDiscoveryTime = control.millis();\n    export function GetPeers() {\n        return new Promise(function (resolve) {\n            findingDevices = true;\n            control.runInParallel(function () {\n\n                for (let i = 0; i < 10; i++) {\n                    if (!findingDevices) break;\n                    radio2.sendString(`pr:*|${mySerial}|FIND`)\n                    pause(10)\n                }\n            })\n            foundDevices = function (dev) {\n                resolve(dev)\n            }\n        })\n    }\n\n    export function getMyIP(): string { return myIP };\n    function Parse(node: any, depth: number, maxDepth: number = 10): any {\n        if (depth > maxDepth) return \"[Max depth exceeded]\";\n\n        // Attempt to parse strings only if they look like structured JSON\n        if (typeof node === \"string\") {\n            const trimmed = node.trim();\n            const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n                (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\n\n            if (looksLikeJson) {\n                try {\n                    const parsed = JSON.parse(node);\n                    return parsed;\n                } catch {\n                    // It's not valid JSON, treat as raw string\n                    return node;\n                }\n            }\n            return node;\n        }\n\n        if (Array.isArray(node)) {\n            return node.map((item: any) => Parse(item, depth + 1));\n        }\n\n        if (typeof node === \"object\" && node !== null && !Array.isArray(node)) {\n            const result: any = {};\n            const keys = Object.keys(node);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                result[key] = Parse(node[key], depth + 1);\n            }\n            return result;\n        }\n\n        // Base case for primitives\n        return node;\n    }\n    /** \n     * Does Not seem to Work.\n    */\n    export function safeParse(input: string): any {\n\n        try {\n            const looksLikeJson = input.trim().startsWith(\"{\") || input.trim().startsWith(\"[\");\n            const initial = looksLikeJson ? JSON.parse(input) : input;\n            return Parse(initial, 0);\n        } catch (e) {\n            console.log(\"Parse failed:\" + e);\n            return null;\n        }\n    }\n\n    export let UseDNSCache = false;\n    let cache: Map<string, { serial: number, timestamp: number }> = new Map()\n\n    function addMapping(ip: string, serial: number) {\n        cache.set(ip, {\n            serial: serial,\n            timestamp: game.runtime()\n        })\n    }\n}","radio2.ts":"\n/**\n * Communicate data using radio packets\n */\n//% color=#E3008C weight=96 icon=\"\\uf012\" groups='[\"Group\", \"Broadcast\", \"Send\", \"Receive\"]'\nnamespace radio2 {\n\n    const RADIO_MAX_PACKET_SIZE = 269;\n    const MAX_FIELD_DOUBLE_NAME_LENGTH = 8;\n    const MAX_PAYLOAD_LENGTH = 256;\n    const PACKET_PREFIX_LENGTH = 9;\n    const VALUE_PACKET_NAME_LEN_OFFSET = 13;\n    const DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET = 17;\n\n    // Packet Spec:\n    // | 0              | 1 ... 4       | 5 ... 8           | 9 ... 109\n    // ----------------------------------------------------------------\n    // | packet type    | system time   | serial number     | payload\n    //\n    // Serial number defaults to 0 unless enabled by user\n\n    // payload: number (9 ... 12)\n    export const PACKET_TYPE_NUMBER = 0;\n    // payload: number (9 ... 12), name length (13), name (14 ... 26)\n    export const PACKET_TYPE_VALUE = 1;\n    // payload: string length (9), string (10 ... 28)\n    export const PACKET_TYPE_STRING = 2;\n    // payload: buffer length (9), buffer (10 ... 28)\n    export const PACKET_TYPE_BUFFER = 3;\n    // payload: number (9 ... 16)\n    export const PACKET_TYPE_DOUBLE = 4;\n    // payload: number (9 ... 16), name length (17), name (18 ... 26)\n    export const PACKET_TYPE_DOUBLE_VALUE = 5;\n\n    const transmittingSerial: boolean = true;\n    let initialized = false;\n    let NoOverRideHandler = false;\n    export let lastPacket: RadioPacket;\n    let onReceivedNumberHandler: (receivedNumber: number) => void;\n    let onReceivedValueHandler: (name: string, value: number) => void;\n    let onReceivedStringHandler: (receivedString: string,packet:RadioPacket) => void;\n    let onReceivedBufferHandler: (receivedBuffer: Buffer) => void;\n\n    function init() {\n        if (initialized) return;\n        initialized = true;\n        radio.onDataReceived(handleDataReceived);\n    }\n\n    function handleDataReceived() {\n        let buffer: Buffer = radio.readRawPacket();\n        while (buffer) {\n            lastPacket = RadioPacket.getPacket(buffer);\n            switch (lastPacket.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_DOUBLE:\n                    if (onReceivedNumberHandler)\n                        onReceivedNumberHandler(lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_VALUE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    if (onReceivedValueHandler)\n                        onReceivedValueHandler(lastPacket.stringPayload, lastPacket.numberPayload);\n                    break;\n                case PACKET_TYPE_BUFFER:\n                    if (onReceivedBufferHandler)\n                        onReceivedBufferHandler(lastPacket.bufferPayload);\n                    break;\n                case PACKET_TYPE_STRING:\n                    if (onReceivedStringHandler)\n                        onReceivedStringHandler(lastPacket.stringPayload,lastPacket);\n                    break;\n            }\n            // read next packet if any\n            buffer = radio.readRawPacket();\n        }\n    }\n\n    /**\n     * Registers code to run when the radio receives a number.\n     */\n    //% help=radio/on-received-number\n    export function onReceivedNumber(cb: (receivedNumber: number) => void) {\n        init();\n        onReceivedNumberHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a key value pair.\n     */\n    //% help=radio/on-received-value\n    export function onReceivedValue(cb: (name: string, value: number) => void) {\n        init();\n        onReceivedValueHandler = cb;\n    }\n\n    /**\n     * Registers code to run when the radio receives a string.\n     */\n    //% help=radio/on-received-string\n    export function onReceivedString(cb: (receivedString: string,packet:RadioPacket) => void,nooverride?:boolean) {\n        if (NoOverRideHandler) return;\n        init();\n        onReceivedStringHandler = cb;\n        if (nooverride == true) NoOverRideHandler = true;\n    }\n\n    /**\n     * Registers code to run when the radio receives a buffer.\n     */\n    //% help=radio/on-received-buffer blockHidden=1\n    export function onReceivedBuffer(cb: (receivedBuffer: Buffer) => void) {\n        init();\n        onReceivedBufferHandler = cb;\n    }\n\n    /**\n     * Returns properties of the last radio packet received.\n     * @param type the type of property to retrieve from the last packet\n     */\n    //% help=radio/received-packet\n    export function receivedPacket(type: number) {\n        if (lastPacket) {\n            switch (type) {\n                case RadioPacketProperty.Time: return lastPacket.time;\n                case RadioPacketProperty.SerialNumber: return lastPacket.serial;\n                case RadioPacketProperty.SignalStrength: return lastPacket.signal;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Gets a packet property.\n     * @param type the packet property type, eg: PacketProperty.time\n     */\n    //% blockId=radio_packet_property block=\"%note\"\n    //% shim=TD_ID blockHidden=1\n    export function _packetProperty(type: RadioPacketProperty): number {\n        return type;\n    }\n\n    export class RadioPacket {\n        public static getPacket(data: Buffer) {\n            if (!data) return undefined;\n            // last 4 bytes is RSSi\n            return new RadioPacket(data);\n        }\n\n        public static mkPacket(packetType: number) {\n            const res = new RadioPacket();\n            res.data[0] = packetType;\n            return res;\n        }\n\n        private constructor(public readonly data?: Buffer) {\n            if (!data) this.data = control.createBuffer(RADIO_MAX_PACKET_SIZE + 4);\n        }\n\n        get signal() {\n            return this.data.getNumber(NumberFormat.Int32LE, this.data.length - 4);\n        }\n\n        get packetType() {\n            return this.data[0];\n        }\n\n        get time() {\n            return this.data.getNumber(NumberFormat.Int32LE, 1);\n        }\n\n        set time(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 1, val);\n        }\n\n        get serial() {\n            return this.data.getNumber(NumberFormat.Int32LE, 5);\n        }\n\n        set serial(val: number) {\n            this.data.setNumber(NumberFormat.Int32LE, 5, val);\n        }\n\n        get stringPayload() {\n            const offset = getStringOffset(this.packetType) as number;\n            return offset ? this.data.slice(offset + 1, this.data[offset]).toString() : undefined;\n        }\n\n        set stringPayload(val: string) {\n            const offset = getStringOffset(this.packetType) as number;\n            if (offset) {\n                const buf = control.createBufferFromUTF8(truncateString(val, getMaxStringLength(this.packetType)));\n                this.data[offset] = buf.length;\n                this.data.write(offset + 1, buf);\n            }\n        }\n\n        get numberPayload() {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    return this.data.getNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH);\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    return this.data.getNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH);\n            }\n            return undefined;\n        }\n\n        set numberPayload(val: number) {\n            switch (this.packetType) {\n                case PACKET_TYPE_NUMBER:\n                case PACKET_TYPE_VALUE:\n                    this.data.setNumber(NumberFormat.Int32LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n                case PACKET_TYPE_DOUBLE:\n                case PACKET_TYPE_DOUBLE_VALUE:\n                    this.data.setNumber(NumberFormat.Float64LE, PACKET_PREFIX_LENGTH, val);\n                    break;\n            }\n        }\n\n        get bufferPayload() {\n            const len = this.data[PACKET_PREFIX_LENGTH];\n            return this.data.slice(PACKET_PREFIX_LENGTH + 1, len);\n        }\n\n        set bufferPayload(b: Buffer) {\n            const len = Math.min(b.length, MAX_PAYLOAD_LENGTH - 1);\n            this.data[PACKET_PREFIX_LENGTH] = len;\n            this.data.write(PACKET_PREFIX_LENGTH + 1, b.slice(0, len));\n        }\n\n        hasString() {\n            return this.packetType === PACKET_TYPE_STRING ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n\n        hasNumber() {\n            return this.packetType === PACKET_TYPE_NUMBER ||\n                this.packetType === PACKET_TYPE_DOUBLE ||\n                this.packetType === PACKET_TYPE_VALUE ||\n                this.packetType === PACKET_TYPE_DOUBLE_VALUE;\n        }\n    }\n\n    /**\n     * Broadcasts a number over radio to any connected micro:bit in the group.\n     */\n    //% help=radio/send-number\n    export function sendNumber(value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_NUMBER);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE);\n        }\n\n        packet.numberPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n    * Broadcasts a name / value pair along with the device serial number\n    * and running time to any connected micro:bit in the group. The name can\n    * include no more than 8 characters.\n    * @param name the field name (max 8 characters), eg: \"name\"\n    * @param value the numeric value\n    */\n    //% help=radio/send-value\n    export function sendValue(name: string, value: number) {\n        let packet: RadioPacket;\n\n        if (value === (value | 0)) {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_VALUE);\n        }\n        else {\n            packet = RadioPacket.mkPacket(PACKET_TYPE_DOUBLE_VALUE);\n        }\n\n        packet.numberPayload = value;\n        packet.stringPayload = name;\n        sendPacket(packet);\n    }\n    \n    /**\n     * Broadcasts a string along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-string\n    export function sendString(value: string) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_STRING);\n        packet.stringPayload = value;\n        sendPacket(packet);\n    }\n\n    /**\n     * Broadcasts a buffer (up to 19 bytes long) along with the device serial number\n     * and running time to any connected micro:bit in the group.\n     */\n    //% help=radio/send-buffer\n    export function sendBuffer(msg: Buffer) {\n        const packet = RadioPacket.mkPacket(PACKET_TYPE_BUFFER);\n        packet.bufferPayload = msg;\n        sendPacket(packet);\n    }\n\n    function sendPacket(packet: RadioPacket) {\n        packet.time = control.millis();\n        packet.serial = control.deviceSerialNumber();\n        radio.sendRawPacket(packet.data);\n    }\n\n    function truncateString(str: string, bytes: number) {\n        str = str.substr(0, bytes);\n        let buff = control.createBufferFromUTF8(str);\n\n        while (buff.length > bytes) {\n            str = str.substr(0, str.length - 1);\n            buff = control.createBufferFromUTF8(str);\n        }\n\n        return str;\n    }\n\n    function getStringOffset(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return PACKET_PREFIX_LENGTH;\n            case PACKET_TYPE_VALUE:\n                return VALUE_PACKET_NAME_LEN_OFFSET;\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return DOUBLE_VALUE_PACKET_NAME_LEN_OFFSET;\n            default:\n                return undefined;\n        }\n    }\n\n    function getMaxStringLength(packetType: number) {\n        switch (packetType) {\n            case PACKET_TYPE_STRING:\n                return MAX_PAYLOAD_LENGTH - 1;\n            case PACKET_TYPE_VALUE:\n            case PACKET_TYPE_DOUBLE_VALUE:\n                return MAX_FIELD_DOUBLE_NAME_LENGTH;\n            default:\n                return undefined;\n        }\n    }\n}","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n//% color=#E3008C weight=96 icon=\"\\uf012\"\ndeclare namespace radio {\n\n    /**\n     * Disables the radio for use as a multipoint sender/receiver.\n     * Disabling radio will help conserve battery power when it is not in use.\n     */\n    //% help=radio/off shim=radio::off\n    function off(): void;\n\n    /**\n     * Initialises the radio for use as a multipoint sender/receiver\n     * Only useful when the radio.off() is used beforehand.\n     */\n    //% help=radio/on shim=radio::on\n    function on(): void;\n\n    /**\n     * Sends an event over radio to neigboring devices\n     */\n    //% blockId=radioRaiseEvent block=\"radio raise event|from source %src=control_event_source_id|with value %value=control_event_value_id\"\n    //% blockExternalInputs=1\n    //% advanced=true\n    //% weight=1\n    //% help=radio/raise-event shim=radio::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Internal use only. Takes the next packet from the radio queue and returns its contents + RSSI in a Buffer.\n     * @returns NULL if no packet available\n     */\n    //% shim=radio::readRawPacket\n    function readRawPacket(): Buffer;\n\n    /**\n     * Internal use only. Sends a raw packet through the radio (assumes RSSI appened to packet)\n     */\n    //% async shim=radio::sendRawPacket\n    function sendRawPacket(msg: Buffer): void;\n\n    /**\n     * Used internally by the library.\n     */\n    //% help=radio/on-data-received\n    //% weight=0\n    //% blockId=radio_datagram_received_event block=\"radio on data received\" blockGap=8\n    //% deprecated=true blockHidden=1 shim=radio::onDataReceived\n    function onDataReceived(body: () => void): void;\n\n    /**\n     * Sets the group id for radio communications. A micro:bit can only listen to one group ID at any time.\n     * @param id the group id between ``0`` and ``255``, eg: 1\n     */\n    //% help=radio/set-group\n    //% weight=100\n    //% blockId=radio_set_group block=\"radio set group %ID\"\n    //% id.min=0 id.max=255\n    //% group=\"Group\" shim=radio::setGroup\n    function setGroup(id: int32): void;\n\n    /**\n     * Change the output power level of the transmitter to the given value.\n     * @param power a value in the range 0..7, where 0 is the lowest power and 7 is the highest. eg: 7\n     */\n    //% help=radio/set-transmit-power\n    //% weight=9 blockGap=8\n    //% blockId=radio_set_transmit_power block=\"radio set transmit power %power\"\n    //% power.min=0 power.max=7\n    //% advanced=true shim=radio::setTransmitPower\n    function setTransmitPower(power: int32): void;\n\n    /**\n     * Change the transmission and reception band of the radio to the given channel\n     * @param band a frequency band in the range 0 - 83. Each step is 1MHz wide, based at 2400MHz.\n     **/\n    //% help=radio/set-frequency-band\n    //% weight=8 blockGap=8\n    //% blockId=radio_set_frequency_band block=\"radio set frequency band %band\"\n    //% band.min=0 band.max=83\n    //% advanced=true shim=radio::setFrequencyBand\n    function setFrequencyBand(band: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n","multidevsettings.ts":"namespace settings {\n    let permissions: string[] = []\n    let waitingForFiles: { filename: string, handler: (filecontents: string) => void }[] = [];\n    NetWorking.WaitForData(\"*\",true).then(function (a: string) {\n        if (a.startsWith(\"readfile|\")) {\n            let file = a.split(\"|\")[1]\n            let ip = a.split(\"|\")[2]\n            if (permissions.includes(file) && exists(file)) {\n                NetWorking.SendDataTo(ip, `file|${file}|${settings.readString(file)}`)\n            }\n        }\n        if (a.startsWith(\"file|\")) {\n            let valid = null;\n            let name = a.split(\"|\")[1]\n            let contents = a.split(\"|\")[2]\n            for (let a of waitingForFiles) {\n                if (a.filename == name && a.handler) {\n                    valid = a;\n                }\n            }\n            if (valid) {\n                valid.handler(contents)\n                valid = null;\n            }\n        }\n    })\n    /**\n * Requests a string file from a remote device over the network.\n * Returns a Promise that resolves with the file contents if successfully retrieved.\n * The file must be granted permission via `addPermission`, or the request will silently fail.\n *\n * @param name - The name of the file to retrieve\n * @returns Promise that resolves with the file contents as a string\n */\n    export function readRemoteFile(name: string) {\n        return new Promise<string>(function (resolve) {\n            waitingForFiles.push({\n                filename: name, handler: function (a) {\n                    if (a) resolve(a)\n                }\n            })\n        })\n    }\n\n    /**\n     * Grants permission for any remote IP to request the specified file.\n     * Once granted, requests to this file will be responded to with its contents (if it exists).\n     *\n     * @param filename - The name of the file to allow access to\n     */\n    export function addPermison(filename: string) {\n        permissions.push(filename)\n    }\n}","pxt.json":"{\n    \"name\": \"makecode-DNS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"dns.ts\",\n        \"radio2.ts\",\n        \"shims.d.ts\",\n        \"multidevsettings.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1759442383347}